<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>网络编程 | miaobuyi</title><meta name="author" content="miaobuyi"><meta name="copyright" content="miaobuyi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络编程Internet历史​	1968：阿帕网问世，internet雏形、不能跨平台、跨操作系统 ​    1974：TCP协议出现、没有纠错功能 ​	1983：TPC&#x2F;IP协议出现 ​				能够实现跨平台、操作系统 ​				能够实现纠错功能 协议：事先约定好的一组规则 网络协议模型1、OSI七层协议模型(理论化的模型)应用层：应用程序 表示层：信息加密、解密 会话层：建立通信节点 传输层：">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程">
<meta property="og:url" content="https://miaobuyi.github.io/2023/04/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="miaobuyi">
<meta property="og:description" content="网络编程Internet历史​	1968：阿帕网问世，internet雏形、不能跨平台、跨操作系统 ​    1974：TCP协议出现、没有纠错功能 ​	1983：TPC&#x2F;IP协议出现 ​				能够实现跨平台、操作系统 ​				能够实现纠错功能 协议：事先约定好的一组规则 网络协议模型1、OSI七层协议模型(理论化的模型)应用层：应用程序 表示层：信息加密、解密 会话层：建立通信节点 传输层：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imgapi.xl0408.top/index.php">
<meta property="article:published_time" content="2023-04-10T10:56:39.000Z">
<meta property="article:modified_time" content="2023-05-02T14:38:36.482Z">
<meta property="article:author" content="miaobuyi">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgapi.xl0408.top/index.php"><link rel="shortcut icon" href="https://typora-1307795383.cos.ap-chengdu.myqcloud.com/avatar.jpg"><link rel="canonical" href="https://miaobuyi.github.io/2023/04/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-02 22:38:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-1307795383.cos.ap-chengdu.myqcloud.com/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://imgapi.xl0408.top/index.php')"><nav id="nav"><span id="blog-info"><a href="/" title="miaobuyi"><span class="site-name">miaobuyi</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-10T10:56:39.000Z" title="发表于 2023-04-10 18:56:39">2023-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-02T14:38:36.482Z" title="更新于 2023-05-02 22:38:36">2023-05-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h3 id="Internet历史"><a href="#Internet历史" class="headerlink" title="Internet历史"></a>Internet历史</h3><p>​	1968：阿帕网问世，internet雏形、不能跨平台、跨操作系统</p>
<p>​    1974：TCP协议出现、没有纠错功能</p>
<p>​	1983：TPC/IP协议出现</p>
<p>​				能够实现跨平台、操作系统</p>
<p>​				能够实现纠错功能</p>
<p>协议：事先约定好的一组规则</p>
<h3 id="网络协议模型"><a href="#网络协议模型" class="headerlink" title="网络协议模型"></a>网络协议模型</h3><h5 id="1、OSI七层协议模型-理论化的模型"><a href="#1、OSI七层协议模型-理论化的模型" class="headerlink" title="1、OSI七层协议模型(理论化的模型)"></a>1、OSI七层协议模型(理论化的模型)</h5><p>应用层：应用程序</p>
<p>表示层：信息加密、解密</p>
<p>会话层：建立通信节点</p>
<p>传输层：完成点对点的通信</p>
<p>网络层：路由寻址(ip)  ip：在网络中唯一标识一台主机</p>
<p>数据链路层：接收物理层的数据，进行帧格式的解包，纠错处理，接受网络层的数据，进行帧格式的打包</p>
<p>物理层：屏蔽物理硬件差异，光电信号的转换</p>
<p>应 表 会 传 网 数 物</p>
<h5 id="2、TCP-x2F-IP四层协议模型"><a href="#2、TCP-x2F-IP四层协议模型" class="headerlink" title="2、TCP/IP四层协议模型"></a>2、TCP/IP四层协议模型</h5><p>应用层:http(超文本传输协议)、FTP（文件传输协议）、DNS（域名解析）、NFS(网络挂载协议)、SSH（远程登录协议）</p>
<p>传输层：TCP协议、UDP协议</p>
<p>网络层：IP协议</p>
<p>物理与网络接口层：以太网协议、PPP(拨号协议)、令牌环网、ARP(ip-&gt;mac)、RARP（mac-&gt;ip)</p>
<figure class="highlight tex"><table><tbody><tr><td class="code"><pre><span class="line">tcp协议和udp协议</span><br><span class="line">    共同点：都是传输层的通信协议</span><br><span class="line">	不同点：</span><br><span class="line">    	tcp：面向连接，保证数据安全、可靠、不失序的一种通信协议</span><br><span class="line">    		应用场景：</span><br><span class="line">    			登录相关程序、重要文件</span><br><span class="line">    	udp：无连接，是一种不安全、不可靠的一种通信协议</span><br><span class="line">    		应用场景：</span><br><span class="line">    			流媒体软件、大型的音视频传输    </span><br></pre></td></tr></tbody></table></figure>



<h3 id="网络编程预备知识"><a href="#网络编程预备知识" class="headerlink" title="网络编程预备知识"></a>网络编程预备知识</h3><h5 id="1、IP地址"><a href="#1、IP地址" class="headerlink" title="1、IP地址"></a>1、IP地址</h5><p>​	IP地址在网络中唯一标识一台主机</p>
<p>​	IPV4：32bit 4字节数据</p>
<p>​			点分十进制：”1.1.1.0”</p>
<p>​			二进制：00000001 00000001 00000001 00000000</p>
<p>​	IPV6：128bit</p>
<p>​	冒分16进制：fe80::58e7:a262:ad38:ee1e%31</p>
<p>​	MAC：48bit全球唯一标识</p>
<p>​		ARP： ip –&gt; MAC</p>
<p>​		RARP: MAC –&gt; ip</p>
<h5 id="2、PORT端口号"><a href="#2、PORT端口号" class="headerlink" title="2、PORT端口号"></a>2、PORT端口号</h5><p>​	一个端口号对应一个进程</p>
<p>​	端口号：2字节，是一个short类型的正整数</p>
<p>​	端口号取值范围：0 ~ 65535</p>
<pre><code> 0不能使用
 1~1023：系统端口，不能使用
 1024~5000：一般应用程序
 5001~65535:系统预留自定义端口
</code></pre>
<h5 id="3、套接字-–socket"><a href="#3、套接字-–socket" class="headerlink" title="3、套接字 –socket"></a>3、套接字 –socket</h5><p>​	进程间通信的机制之一</p>
<p>​	本质：是一个特殊的文件描述符，是一个按顺序分配的最小的非负整数</p>
<h3 id="基于TCP的套接字通信流程"><a href="#基于TCP的套接字通信流程" class="headerlink" title="基于TCP的套接字通信流程"></a>基于TCP的套接字通信流程</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><h5 id="1、创建套接字（socket）"><a href="#1、创建套接字（socket）" class="headerlink" title="1、创建套接字（socket）"></a>1、创建套接字（socket）</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">&lt;sys/socket.h&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">	domain:指定通信所用的协议族，</span><br><span class="line">		AF_INET 表示使用 IPv4 协议族；</span><br><span class="line">        AF_UNIX 或 AF_LOCAL：用于本地通信的协议族；</span><br><span class="line">        AF_INET6：用于 IPv6 协议族的套接字；</span><br><span class="line">        AF_IPX：用于 IPX 协议族的套接字；</span><br><span class="line">        AF_NETLINK：用于内核和用户进程之间的通信；</span><br><span class="line">        AF_PACKET：用于底层数据包操作的协议族。</span><br><span class="line">	type:参数指定套接字的类型</span><br><span class="line">        SOCK_STREAM 表示使用流套接字（TCP）</span><br><span class="line">        SOCK_DGRAM 表示使用数据报套接字（UDP）</span><br><span class="line">        SOCK——RAM 原始套接字，跨传输层的通信--ping</span><br><span class="line">	protocol:参数指定具体的协议，</span><br><span class="line">        通常取值为 <span class="number">0</span>，表示自动选择适合该套接字类型和协议族的默认协议。</span><br><span class="line">返回值：返回一个整数类型的套接字描述符，它作为后续的网络通信操作的参数之一。如果调用失败，socket()函数会返回 <span class="number">-1</span>，并设置全局变量 errno 表示具体的错误原因。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2、命名套接字、绑定（bind）"><a href="#2、命名套接字、绑定（bind）" class="headerlink" title="2、命名套接字、绑定（bind）"></a>2、命名套接字、绑定（bind）</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用地址结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> {</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;   <span class="comment">// 地址族，如 AF_INET、AF_INET6</span></span><br><span class="line">    <span class="type">char</span>        sa_data[<span class="number">14</span>]; <span class="comment">// 地址数据</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4地址结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> {</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr; <span class="comment">// IP地址，使用网络字节序</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//Internet协议地址结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> {</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="comment">// 地址族，始终为 AF_INET</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="comment">// 端口号，使用网络字节序（big-endian）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// IP地址，使用网络字节序</span></span><br><span class="line">    <span class="type">char</span>           sin_zero[<span class="number">8</span>];<span class="comment">// 未使用</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>bind</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">    sockfd：要绑定的套接字文件描述符。</span><br><span class="line">    addr：指向要绑定的地址结构体(如 <span class="keyword">struct</span> sockaddr_in)的指针。</span><br><span class="line">    addrlen：地址结构体的长度。</span><br><span class="line">	返回值：函数执行成功后，套接字就与指定的地址和端口号相关联。如果绑定失败，bind() 函数将返回一个负数，表示绑定失败的原因。</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bind(server_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) {</span><br><span class="line">    perror(<span class="string">"bind failed"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>第二个参数为什么要这样写?</p>
</blockquote>
<blockquote>
<p>在调用 <code>bind()</code> 函数时，第二个参数需要传递一个指向地址结构体的指针，即 <code>const struct sockaddr *addr</code>。但是，<code>server_address</code> 是一个类型为 <code>struct sockaddr_in</code> 的结构体，因此在传递给 <code>bind()</code> 函数之前需要将其转换为 <code>struct sockaddr</code> 类型的指针。</p>
<p>这里采用了一个常用的技巧，即将结构体指针强制转换为通用的 <code>struct sockaddr</code> 指针类型，这样可以避免在函数调用过程中出现类型不匹配的问题。</p>
<p>具体来说，代码中将 <code>server_address</code> 的地址作为参数传递给 <code>bind()</code> 函数时，将其强制转换为 <code>struct sockaddr</code> 类型的指针，即 <code>(struct sockaddr *)&amp;server_address</code>。这样做不会改变地址结构体中的数据内容，只是改变了指针的类型，使得在函数调用中能够通过 <code>struct sockaddr</code> 类型的指针正确地访问 <code>server_address</code> 中的数据。</p>
</blockquote>
<h5 id="3、创建监听队列（listen）"><a href="#3、创建监听队列（listen）" class="headerlink" title="3、创建监听队列（listen）"></a>3、创建监听队列（listen）</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line">    sockfd：已创建并绑定地址的套接字文件描述符；</span><br><span class="line">    backlog：等待连接队列的最大长度，即同一时刻可以接受的最大连接请求数量。</span><br><span class="line">	返回值：函数成功返回 <span class="number">0</span>，失败返回 <span class="number">-1</span>。在返回之前，系统会将 sockfd 标识为被动套接字，表示该套接字可以接收客户端连接请求。</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>需要注意的是，调用 <code>listen()</code> 函数后并不会立即阻塞等待客户端连接请求，需要在调用 <code>accept()</code> 函数前将 sockfd 设置为非阻塞模式，或者在 <code>accept()</code> 函数中使用超时机制等待连接请求的到来。</p>
</blockquote>
<h5 id="4、接受连接（accept）"><a href="#4、接受连接（accept）" class="headerlink" title="4、接受连接（accept）"></a>4、接受连接（accept）</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">    sockfd：已调用 listen() 函数的套接字文件描述符；</span><br><span class="line">    addr：用于存放客户端地址信息的结构体指针；</span><br><span class="line">    addrlen：指向 addr 结构体的长度的指针。</span><br><span class="line">    返回值：函数成功返回一个新的套接字文件描述符---读写套接字，用于与客户端通信；若失败则返回 <span class="number">-1</span>。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="5、读写数据"><a href="#5、读写数据" class="headerlink" title="5、读写数据"></a>5、读写数据</h5><h6 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h6><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line">    sockfd：要接收数据的套接字文件描述符。</span><br><span class="line">    buf：指向存放接收数据的缓冲区的指针。</span><br><span class="line">    len：缓冲区的长度。</span><br><span class="line">    flags：接收操作的标志，通常设置为 <span class="number">0</span> 阻塞。</span><br><span class="line">        MSG_WAITALL：表示在接收到完整的请求后，才返回数据。即一直等到 len 个字节的数据都接收完毕后才返回，如果接收到的数据长度小于 len，则 recv() 函数将一直等待，直到接收到足够的数据后才返回。如果不设置该标志，则在接收到任意长度的数据后即返回，可能会导致接收到的数据不完整。</span><br><span class="line">		MSG_OOB：表示接收带外数据（Out-of-Band Data）。</span><br><span class="line">		MSG_PEEK：表示接收数据但不将其从接收缓冲区中删除。这意味着，在下一次调用 recv() 函数时，仍然可以读取到这些数据。</span><br><span class="line">		MSG_DONTWAIT：表示以非阻塞方式进行接收操作。如果接收缓冲区中没有数据可读，则 recv() 函数会立即返回，而不会等待数据到达。</span><br><span class="line">    返回值：recv() 函数执行成功后，返回值为接收到的数据的字节数。如果接收失败，recv() 函数将返回一个负数，表示接收失败的原因。</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>需要注意的是，不同的操作系统可能支持的 <code>recv()</code> 函数的 <code>flags</code> 标志略有不同，因此在使用时应注意查看所使用操作系统的文档。</p>
</blockquote>
<h6 id="send"><a href="#send" class="headerlink" title="send"></a>send</h6><p><code>send()</code>是一个函数，用于在已连接的套接字上发送数据。在TCP协议中，使用<code>send()</code>函数将数据发送给已连接的远程主机，可以在客户端和服务器之间进行双向通信。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line">	sockfd是指向已连接套接字的文件描述符；</span><br><span class="line">	buf是指向包含要发送的数据的缓冲区指针；</span><br><span class="line">    len是要发送的数据的长度；</span><br><span class="line">    flags是一组标志，用于控制发送操作的行为。</span><br><span class="line"></span><br><span class="line">	返回值：函数返回值为<span class="type">ssize_t</span>类型，表示发送成功的数据字节数。如果发送失败，则返回<span class="number">-1</span>，并设置全局变量errno来指示错误原因。</span><br></pre></td></tr></tbody></table></figure>

<p>在调用<code>send()</code>函数时，需要注意以下几点：</p>
<ul>
<li>发送操作可能会阻塞，直到发送缓冲区中的数据被完全传输或发生错误。</li>
<li>如果要发送的数据长度大于发送缓冲区的大小，数据将被分成多个数据包进行发送。</li>
<li>一般情况下，TCP协议保证数据包的有序性，即发送的数据包将按照发送的顺序到达远程主机。但是，如果数据包经过多个网络节点传输，可能会出现乱序现象，需要使用TCP协议的确认机制进行重传和排序。</li>
<li>如果使用带外数据传输（OOB）发送数据，需要使用<code>MSG_OOB</code>标志。</li>
</ul>
<h5 id="6、关闭连接"><a href="#6、关闭连接" class="headerlink" title="6、关闭连接"></a>6、关闭连接</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">close(fd)</span><br><span class="line"><span class="comment">//fd 套接字描述符</span></span><br></pre></td></tr></tbody></table></figure>



<h5 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> server_sockfd, client_sockfd;</span><br><span class="line">    <span class="type">socklen_t</span> server_len, client_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名套接字</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_address.sin_port = htons(<span class="number">9734</span>);</span><br><span class="line">    server_len = <span class="keyword">sizeof</span>(server_address);</span><br><span class="line">    bind(server_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_address, server_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听队列</span></span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server waiting\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        client_len = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">        client_sockfd = accept(server_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">        read(client_sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">        ch++;</span><br><span class="line">        write(client_sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        close(client_sockfd);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><h5 id="1、创建套接字"><a href="#1、创建套接字" class="headerlink" title="1、创建套接字"></a>1、创建套接字</h5><h5 id="2、填写服务器地址结构体"><a href="#2、填写服务器地址结构体" class="headerlink" title="2、填写服务器地址结构体"></a>2、填写服务器地址结构体</h5><h5 id="3、连接服务器"><a href="#3、连接服务器" class="headerlink" title="3、连接服务器"></a>3、连接服务器</h5><p><code>connect()</code>是一个函数，用于建立连接到指定远程主机的TCP连接。在建立连接后，可以使用<code>read()</code>和<code>write()</code>等函数在套接字上发送和接收数据。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	sockfd是指向已创建套接字的文件描述符；</span><br><span class="line">    addr是指向包含远程主机地址和端口号的sockaddr结构体指针；</span><br><span class="line">    addrlen是sockaddr结构体的长度。</span><br><span class="line"></span><br><span class="line">    返回值：函数返回值为<span class="type">int</span>类型，表示函数的执行结果。如果成功建立连接，则返回<span class="number">0</span>；如果失败，则返回<span class="number">-1</span>，并设置全局变量errno来指示错误原因。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="4、读写数据"><a href="#4、读写数据" class="headerlink" title="4、读写数据"></a>4、读写数据</h5><h5 id="5、关闭连接"><a href="#5、关闭连接" class="headerlink" title="5、关闭连接"></a>5、关闭连接</h5><h5 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">socklen_t</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填写服务器地址结构体</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr = *(<span class="keyword">struct</span> in_addr *)*host-&gt;h_addr_list;</span><br><span class="line">    address.sin_port = htons(<span class="number">9734</span>);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    result = connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"oops: client1"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写数据</span></span><br><span class="line">    write(sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    read(sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char from server = %c\n"</span>, ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>服务端代码与之前的示例代码类似，客户端代码则将连接到本地主机的特定端口改为连接到远程主机的特定端口。客户端代码使用<code>gethostbyname()</code>函数获取远程主机的IP地址，并使用<code>connect()</code>函数连接到该IP地址和端口。</p>
<h3 id="基于UDP的套接字通信流程"><a href="#基于UDP的套接字通信流程" class="headerlink" title="基于UDP的套接字通信流程"></a>基于UDP的套接字通信流程</h3><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><h5 id="1、创建套接字-1"><a href="#1、创建套接字-1" class="headerlink" title="1、创建套接字"></a>1、创建套接字</h5><h5 id="2、绑定ip地址端口号"><a href="#2、绑定ip地址端口号" class="headerlink" title="2、绑定ip地址端口号"></a>2、绑定ip地址端口号</h5><h5 id="3、接收，发送"><a href="#3、接收，发送" class="headerlink" title="3、接收，发送"></a>3、接收，发送</h5><h6 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h6><p><code>sendto()</code>是一个函数，用于在未连接的套接字上发送数据。在UDP协议中，使用<code>sendto()</code>函数将数据发送给指定的远程主机，可以进行单向的无连接通信。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	sockfd是指向未连接套接字的文件描述符；</span><br><span class="line">	buf是指向包含要发送的数据的缓冲区指针；</span><br><span class="line">    len是要发送的数据的长度；</span><br><span class="line">    flags是一组标志，用于控制发送操作的行为；</span><br><span class="line">        <span class="number">0</span>：默认选项，不进行任何操作。</span><br><span class="line">        MSG_DONTROUTE：数据包不要路由，只在本地网络中查找接收方。</span><br><span class="line">        MSG_DONTWAIT：非阻塞操作，如果发送缓冲区已满，则立即返回一个错误。</span><br><span class="line">        MSG_EOR：表示此次发送是一个消息的结尾，对于面向消息的协议比如SOCK_DGRAM有效。</span><br><span class="line">        MSG_MORE：表示此次发送是一个长消息的一部分，还有后续数据需要发送。</span><br><span class="line">        MSG_NOSIGNAL：发送操作不会产生SIGPIPE信号，该信号可能会在连接中断或者对端关闭连接时发出。</span><br><span class="line">        MSG_OOB：发送紧急数据，通常是高优先级数据，需要在数据中标记。</span><br><span class="line">        MSG_WAITALL：阻塞操作，直到所有数据都被接收或者出现错误。</span><br><span class="line">    dest_addr是指向包含远程主机地址和端口号的sockaddr结构体指针；</span><br><span class="line">    addrlen是sockaddr结构体的长度。</span><br><span class="line">	返回值：函数返回值为<span class="type">ssize_t</span>类型，表示发送成功的数据字节数。如果发送失败，则返回<span class="number">-1</span>，并设置全局变量errno来指示错误原因。</span><br></pre></td></tr></tbody></table></figure>

<p>在调用<code>sendto()</code>函数时，需要注意以下几点：</p>
<ul>
<li><p>发送操作可能会阻塞，直到发送缓冲区中的数据被完全传输或发生错误。</p>
</li>
<li><p>如果要发送的数据长度大于发送缓冲区的大小，数据将被分成多个数据包进行发送。</p>
</li>
<li><p>UDP协议不保证数据包的有序性，即发送的数据包不一定按照发送的顺序到达远程主机。如果需要保证有序性，需要在应用层使用序号进行排序。</p>
</li>
<li><p>在未连接的套接字上使用<code>sendto()</code>函数发送数据时，需要指定目标主机的地址和端口号，否则发送的数据将无法到达目标主机</p>
</li>
</ul>
<h6 id="recvform"><a href="#recvform" class="headerlink" title="recvform"></a>recvform</h6><blockquote>
<p><code>recvfrom()</code> 函数与 <code>recv()</code> 函数类似，都是用于从套接字中接收数据。不同之处在于，<code>recvfrom()</code> 函数可以从未连接套接字（如 <code>SOCK_DGRAM</code> 类型的套接字）中接收数据，并返回数据发送者的地址信息。</p>
</blockquote>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,<span class="keyword">struct</span> sockaddr *src_addr,<span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">    sockfd：需要接收数据的套接字描述符。</span><br><span class="line">    buf：接收数据的缓冲区指针。</span><br><span class="line">    len：缓冲区的长度。</span><br><span class="line">    flags：接收数据的行为控制参数，常用的有 MSG_WAITALL、MSG_PEEK、MSG_OOB 和 MSG_DONTWAIT。</span><br><span class="line">        其中，flags参数表示函数调用的标志，是一个掩码值，可以用位运算符组合以下标志：</span><br><span class="line">    MSG_CONFIRM：请求确认数据已到达。</span><br><span class="line">    MSG_DONTROUTE：不要将数据路由到其他网络接口，仅在本地网络内寻找目标地址。</span><br><span class="line">    MSG_DONTWAIT：将接收操作设置为非阻塞模式。</span><br><span class="line">    MSG_ERRQUEUE：如果有错误发生，将错误信息放入一个错误队列。</span><br><span class="line">    MSG_OOB：接收带外数据。</span><br><span class="line">    MSG_PEEK：接收数据但不从输入队列中删除。</span><br><span class="line">    MSG_TRUNC：如果接收到的数据超出缓冲区长度，将截断数据并返回缓冲区长度。</span><br><span class="line">    MSG_WAITALL：等待所有请求的字节数都被接收到。</span><br><span class="line">    其中，MSG_CONFIRM和MSG_ERRQUEUE标志只适用于UDP协议。其他标志可以在TCP和UDP协议中使用。</span><br><span class="line">    src_addr：用于存储数据发送者的地址信息，为 sockaddr 类型指针。</span><br><span class="line">    addrlen：存储 src_addr 结构体长度的指针。</span><br><span class="line">	返回值：当成功接收到数据时，recvfrom() 函数会返回接收到的字节数，当出错时返回 <span class="number">-1</span>，并设置 errno 变量以指示错误原因。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4、关闭连接"><a href="#4、关闭连接" class="headerlink" title="4、关闭连接"></a>4、关闭连接</h5><h3 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h3><h5 id="1、循环服务器"><a href="#1、循环服务器" class="headerlink" title="1、循环服务器"></a>1、循环服务器</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">socket()</span><br><span class="line">bind()</span><br><span class="line">listen()</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    accept();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        read()/write();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}       </span><br></pre></td></tr></tbody></table></figure>



<h5 id="2、并发服务器"><a href="#2、并发服务器" class="headerlink" title="2、并发服务器"></a>2、并发服务器</h5><p>(1)多进程并发服务器</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"><span class="type">int</span> connfd;</span><br><span class="line">signal(<span class="number">17</span>, func);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">	connfd = accept();</span><br><span class="line">	<span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//处理客户端信息</span></span><br><span class="line">            ret = read();</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                close(connfd);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } </span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>（2）多线程并发服务器</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">pthread_t</span> thread1;</span><br><span class="line">	socket();</span><br><span class="line">	bind();</span><br><span class="line">	listen();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">    	connfd = accept();</span><br><span class="line">    	pthread_create(&amp;thread1, <span class="literal">NULL</span>, func, &amp;connfd);</span><br><span class="line">    	pthread_detach();    </span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3、TCP通信的三次握手过程"><a href="#3、TCP通信的三次握手过程" class="headerlink" title="3、TCP通信的三次握手过程"></a>3、TCP通信的三次握手过程</h5><p><img src="https://typora-1307795383.cos.ap-chengdu.myqcloud.com/typora/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<p>​	第一次握手：客户端向服务器发送 SYN（x）待确认数据标志位的信息，进入SYN_SEND状态</p>
<p>​	第二次握手：服务器向客户端回传一条ACK (x+1)应答,同时带上SYN（y）待确认数据标志位，进入SYN_RECV状态</p>
<p>​	第三次握手：客户端向服务器回传一条ACK( y+1)应答 ，当三次握手完成之后，客户端和服务器同时进入ESTABLISHED(已连接)状态</p>
<h5 id="4、四次挥手过程"><a href="#4、四次挥手过程" class="headerlink" title="4、四次挥手过程"></a>4、四次挥手过程</h5><p><img src="https://typora-1307795383.cos.ap-chengdu.myqcloud.com/typora/I1QNDFV_J$%7D7CI556TQ@OX7.jpg" alt="img"></p>
<blockquote>
<p>第一次：主动方向被动方发送断开连接请求，带上标志位FIN(x)，进入FIN_WAIT1状态</p>
</blockquote>
<blockquote>
<p>第二次：被动方向主动方回传ACK(x+1)应答, 主动方进入FIN_WAIT2状态, 被动方进入CLOSE_WAIT状态</p>
</blockquote>
<blockquote>
<p>第三次：被动方向被主动方发送断开连接请求，带上标志位FIN(y)，进入LAST_FIN状态</p>
</blockquote>
<blockquote>
<p>第四次：主动方向被动方回传ACK(y+1)应答, 主动方进入TIME_WAIT状态被动,方在接收到ACK应答之后，双方同时进入CLOSE状态</p>
</blockquote>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h5 id="ntohs"><a href="#ntohs" class="headerlink" title="ntohs"></a>ntohs</h5><p><code>ntohs()</code>是一个函数，它的作用是将一个16位的网络字节序整数转换成主机字节序整数。其中，<code>ntohs</code>是<code>network to host short</code>的缩写，用于将网络字节序的短整数转换为主机字节序的短整数。</p>
<p>在使用套接字进行网络通信时，接收到的数据通常是网络字节序的，需要使用<code>ntohs()</code>将其转换为主机字节序的数据。例如，如果我们从套接字中接收到一个表示端口号的16位整数，可以使用<code>ntohs()</code>函数将其转换为主机字节序的端口号。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br><span class="line">	<span class="comment">//netshort是网络字节序的短整数，uint16_t是无符号16位整数类型。</span></span><br><span class="line">	<span class="comment">//函数返回主机字节序的短整数。</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="ntohl"><a href="#ntohl" class="headerlink" title="ntohl"></a>ntohl</h5><p><code>ntohl()</code>是一个函数，它的作用是将一个32位的网络字节序整数转换成主机字节序整数。其中，<code>ntohl</code>是<code>network to host long</code>的缩写，用于将网络字节序的长整数转换为主机字节序的长整数。</p>
<p>在使用套接字进行网络通信时，接收到的数据通常是网络字节序的，需要使用<code>ntohl()</code>将其转换为主机字节序的数据。例如，如果我们从套接字中接收到一个表示IP地址的32位整数，可以使用<code>ntohl()</code>函数将其转换为主机字节序的IP地址。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line">	<span class="comment">//netlong是网络字节序的长整数，uint32_t是无符号32位整数类型。</span></span><br><span class="line">	<span class="comment">//函数返回主机字节序的长整数。</span></span><br></pre></td></tr></tbody></table></figure>



<h5 id="htons"><a href="#htons" class="headerlink" title="htons"></a>htons</h5><p><code>htons()</code> 函数用于将一个 16 位无符号整数从主机字节序转换为网络字节序。在网络字节序中，字节序是大端字节序，即高位字节在前，低位字节在后。而在不同的计算机体系结构中，字节序可能不同，主机字节序和网络字节序也可能不同，因此需要进行转换。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line">	<span class="comment">//其中，`hostshort` 表示需要转换的 16 位无符号整数，函数返回值为转换后的网络字节序的值。</span></span><br></pre></td></tr></tbody></table></figure>

<p>​		该函数在处理网络数据包时非常常用，例如在将本地计算机上的数据发送到网络中或从网络中接收数据时，需要进行字节序的转换。</p>
<h5 id="htonl"><a href="#htonl" class="headerlink" title="htonl"></a><strong>htonl</strong></h5><p><code>htonl()</code> 函数用于将一个 32 位无符号整数从主机字节序转换为网络字节序。在网络字节序中，字节序是大端字节序，即高位字节在前，低位字节在后。而在不同的计算机体系结构中，字节序可能不同，主机字节序和网络字节序也可能不同，因此需要进行转换。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"><span class="comment">//其中，`hostlong` 表示需要转换的 32 位无符号整数，函数返回值为转换后的网络字节序的值。</span></span><br></pre></td></tr></tbody></table></figure>

<p>​		该函数在处理网络数据包时非常常用，例如在将本地计算机上的数据发送到网络中或从网络中接收数据时，需要进行字节序的转换。</p>
<h5 id="inet-addr"><a href="#inet-addr" class="headerlink" title="inet_addr"></a>inet_addr</h5><p><code>inet_addr()</code> 函数用于将一个 IPv4 地址字符串转换为网络字节序的 32 位无符号整数。IPv4 地址通常以点分十进制的格式表示，如 <code>192.168.1.1</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line">	<span class="comment">//cp:表示需要转换的 IPv4 地址字符串，</span></span><br><span class="line">	<span class="comment">//函数返回值为转换后的网络字节序的 32 位无符号整数。如果转换失败，则返回 `INADDR_NONE`。</span></span><br></pre></td></tr></tbody></table></figure>

<p>​		该函数在套接字编程中非常常用，例如在创建套接字、绑定套接字地址等操作中需要将字符串类型的 IP 地址转换为网络字节序的整数类型。</p>
<h5 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa"></a>inet_ntoa</h5><p><code>inet_ntoa()</code> 函数用于将一个网络字节序的 32 位无符号整数表示的 IPv4 地址转换为点分十进制的格式。IPv4 地址通常以点分十进制的格式表示，如 <code>192.168.1.1</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"><span class="comment">//in 表示需要转换的网络字节序的 32 位无符号整数表示IPv4 地址，函数返回值为转换后的点分十进制的格式的字符串。</span></span><br></pre></td></tr></tbody></table></figure>

<p>​		该函数在套接字编程中非常常用，例如在打印套接字地址时需要将网络字节序的 IP 地址转换为字符串类型的点分十进制格式。需要注意的是，该函数返回的指针指向的是一个静态缓冲区，因此不应该修改该指针所指向的内容，也不应该在多个地方使用相同的指针。</p>
<h5 id="inet-aton"><a href="#inet-aton" class="headerlink" title="inet_aton"></a>inet_aton</h5><p><code>inet_aton()</code>函数与<code>inet_addr()</code>函数作用相同，都是将字符串形式的IP地址转换为32位的网络字节序二进制数。但它们的函数原型略有不同：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line">	cp是待转换的字符串形式的IP地址；</span><br><span class="line">    inp是用于存储转换后的<span class="number">32</span>位网络字节序二进制数的in_addr结构体指针。</span><br><span class="line">    返回值：inet_aton()函数成功返回<span class="number">1</span>，失败返回<span class="number">0</span>。</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>相对于<code>inet_addr()</code>函数，<code>inet_aton()</code>函数的优点在于它可以通过返回值来判断转换是否成功，而<code>inet_addr()</code>函数只能通过返回值是否为<code>INADDR_NONE</code>来判断是否成功。</p>
</blockquote>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>​		计算机在存储数据时，可以采用<code>大端序</code>（Big-Endian）或<code>小端序</code>（Little-Endian）两种方式。大端序是指将高位字节存储在低地址，低位字节存储在高地址；小端序则是将低位字节存储在低地址，高位字节存储在高地址。这个问题主要涉及到多个字节数据在计算机中存储的方式。</p>
<p>​		在网络通信中，需要将数据从一台计算机传输到另一台计算机上。如果这两台计算机采用的字节序不同，那么就需要进行字节序的转换。通常情况下，网络通信采用的是大端序，也就是高位字节先传输。</p>
<p><code>小端序</code>&lt;——-&gt;<code>本机字节序</code></p>
<p><code>大端序 </code>&lt;——-&gt;<code>网络字节序</code></p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><h4 id="1、阻塞IO"><a href="#1、阻塞IO" class="headerlink" title="1、阻塞IO"></a>1、阻塞IO</h4><p>​	读阻塞：当缓冲区中无数据，或者需要等待某种资源时，就会发生读阻塞</p>
<p>​					read、recv、fgets、scanf….</p>
<p>​	写阻塞：当缓冲区没有足够空间时，发生写阻塞</p>
<p>​					write、send…..</p>
<p>​	在程序中使用阻塞IO时，有可能会阻碍其他代码的执行</p>
<blockquote>
<p>阻塞式IO模型是指当进程执行IO操作时，如果数据没有准备好，进程会被阻塞，直到数据准备好才会返回。这种模型的优点是简单，易于实现，缺点是会浪费CPU资源，因为进程在等待IO完成时会一直占用CPU资源。</p>
</blockquote>
<h4 id="2、非阻塞IO"><a href="#2、非阻塞IO" class="headerlink" title="2、非阻塞IO"></a>2、非阻塞IO</h4><blockquote>
<p>非阻塞式IO模型是指当进程执行IO操作时，如果数据没有准备好，进程不会被阻塞，而是立即返回一个错误码。进程可以继续执行其他操作，然后再通过轮询等方式来检查IO操作是否完成。这种模型的优点是可以避免浪费CPU资源，缺点是轮询等操作会浪费一定的CPU时间。</p>
</blockquote>
<p>​	非阻塞IO会频繁调用函数，开销较大</p>
<p>​	设置非阻塞相关函数 – <code>fcntl</code></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    cmd：</span><br><span class="line">        F_GETFL:获取文件属性状态</span><br><span class="line">        F_SETFL:设置文件属性状态</span><br><span class="line">	返回值：</span><br><span class="line">        根据参数cmd的不同返回不同的值</span><br><span class="line">        cmd -- F_GETFL:返回获取的文件属性状态</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="number">1</span>、获取文件描述符对应属性状态</span><br><span class="line"><span class="type">int</span> flag = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span>、将flag添加设置非阻塞方式</span><br><span class="line">    flag = flag | O_NONBLOCK;</span><br><span class="line"><span class="number">3</span>、将新的状态属性设置到文件描述符中</span><br><span class="line">    fcntl(fd, F_SETFL, flag);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="3、IO多路复用"><a href="#3、IO多路复用" class="headerlink" title="3、IO多路复用"></a>3、IO多路复用</h4><blockquote>
<p>非阻塞式IO模型是指当进程执行IO操作时，如果数据没有准备好，进程不会被阻塞，而是立即返回一个错误码。进程可以继续执行其他操作，然后再通过轮询等方式来检查IO操作是否完成。这种模型的优点是可以避免浪费CPU资源，缺点是轮询等操作会浪费一定的CPU时间。</p>
</blockquote>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">     <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">     <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">                fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">参数：</span><br><span class="line">          nfds：监测的文件描述符表中的文件描述最大值+<span class="number">1</span></span><br><span class="line">	readfds：读监测表的首地址，不需要填<span class="literal">NULL</span></span><br><span class="line">          writefds：写监测表的首地址，不需要填<span class="literal">NULL</span></span><br><span class="line">          exceptfds：异常监测表的首地址，不需要填<span class="literal">NULL</span></span><br><span class="line">          timeout：设置的超时时间的首地址,不设置超时时间填<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">     <span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>; <span class="comment">//从表中删除文件描述符</span></span><br><span class="line">     <span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>; <span class="comment">//判断指定的文件描述符是否有响应，结果为真--有响应</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>; <span class="comment">//向表中添加文件描述符</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;  <span class="comment">//清0文件描述符表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> {</span></span><br><span class="line">             <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">             <span class="type">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">        };		</span><br><span class="line">  timeout的使用方法：</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">mt</span>;</span></span><br><span class="line">	mt.tv_sec = <span class="number">10</span>;</span><br><span class="line">	mt.tv_usec = <span class="number">500</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>select机制流程：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>、定义监测表,清空表</span><br><span class="line">   	fd_set rfds;</span><br><span class="line">	FD_ZERO(&amp;rfds);</span><br><span class="line"><span class="number">2</span>、向表中添加要监测的文件描述符<span class="number">0</span>、<span class="number">3</span></span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;rfds);</span><br><span class="line">	FD_SET(<span class="number">3</span>, &amp;rfds);</span><br><span class="line">	<span class="type">int</span> maxfd = <span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line"><span class="number">3</span>、循环监测表</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        select(maxfd, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; maxfd; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i, &amp;rfds))</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                   <span class="comment">//实现对应IO操作 </span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//实现对应IO操作</span></span><br><span class="line">                }   </span><br><span class="line">            }           </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用select实现服务器的并发</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> {</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="type">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line">    <span class="type">int</span> ret = bind(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, s_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bind success\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    listen(sockfd, <span class="number">5</span>);</span><br><span class="line">    fd_set rfds,tmp;</span><br><span class="line">    FD_ZERO(&amp;rfds);</span><br><span class="line">    FD_SET(sockfd, &amp;rfds);</span><br><span class="line">    <span class="type">int</span> maxfd = sockfd;</span><br><span class="line">    tmp=rfds;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        rfds=tmp;</span><br><span class="line">        select(maxfd + <span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxfd; i++) {</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(i, &amp;rfds)) {</span><br><span class="line">                <span class="keyword">if</span> (i == sockfd) { <span class="comment">//sockfd有反应将返回回来的套接字加入监听</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">                    <span class="type">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line">                    <span class="type">int</span> connfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;caddr, &amp;c_len);</span><br><span class="line">                    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) {</span><br><span class="line">                        perror(<span class="string">"accept"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"link success\n"</span>);</span><br><span class="line">                    }</span><br><span class="line">                    maxfd = maxfd&gt;connfd?maxfd:connfd;<span class="comment">//保存最大的文件描述符</span></span><br><span class="line">                    FD_SET(connfd, &amp;tmp);<span class="comment">//更新表</span></span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">//接收</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">                    read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="comment">//客户端退出</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf,<span class="string">"quit"</span>,<span class="number">4</span>)==<span class="number">0</span>){</span><br><span class="line">                        FD_CLR(i,&amp;tmp);</span><br><span class="line">                        close(i);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"socket:%d--quit\n"</span>, i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"socket:%d--%s"</span>, i,buf);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p><code>poll</code>是一个系统级函数，用于在Linux/Unix系统中进行轮询等待多个文件描述符上的事件。它通常用于异步I/O编程中，可以让程序等待多个I/O事件而不会被阻塞。</p>
<p>在使用<code>poll</code>函数之前，需要先定义一个<code>struct pollfd</code>类型的数组，每个数组元素表示一个文件描述符和它所关心的事件。<code>poll</code>函数会等待这些文件描述符上的事件，并将结果存储在<code>struct pollfd</code>类型的数组中。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	fds参数:是一个指向<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>类型数组的指针</span></span><br><span class="line"><span class="class">    <span class="title">nfds</span>参数表示数组中元素的数量</span></span><br><span class="line"><span class="class">    <span class="title">timeout</span>参数表示等待的超时时间（以毫秒为单位）。</span></span><br><span class="line"><span class="class">    返回值：<span class="title">poll</span>函数返回值表示发生事件的文件描述符数量，或者在超时时返回0，发生错误时返回-1。</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> {</span></span><br><span class="line">    <span class="type">int</span> fd;          <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;    <span class="comment">// 要监听的事件</span></span><br><span class="line">    <span class="type">short</span> revents;   <span class="comment">// 实际发生的事件</span></span><br><span class="line">};</span><br><span class="line">fd字段表示要监听的文件描述符，</span><br><span class="line">events字段表示要监听的事件，</span><br><span class="line">revents字段表示实际发生的事件，是由poll函数填充的。</span><br><span class="line">events和revents字段的值是由以下宏定义组成的位掩码：</span><br><span class="line"></span><br><span class="line">    POLLIN：表示可以从文件描述符读取数据。</span><br><span class="line">    POLLOUT：表示可以向文件描述符写入数据。</span><br><span class="line">    POLLERR：表示文件描述符发生了错误。</span><br><span class="line">    POLLHUP：表示文件描述符挂起。</span><br><span class="line">    POLLNVAL：表示文件描述符无效。</span><br><span class="line">    events和revents字段的值可以使用位运算符进行组合。例如，要监听读事件和错误事件，可以使用以下语句：</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br></pre></td></tr></tbody></table></figure>



<p>简单示例</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> {</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"/dev/input/mice"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       int flag = fcntl(0,F_GETFL,0);</span></span><br><span class="line"><span class="comment">       flag = flag | O_NONBLOCK;</span></span><br><span class="line"><span class="comment">       fcntl(0,F_SETFL,flag);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfds</span>[200];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">200</span>;i++){</span><br><span class="line">        pfds[i].fd=<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pos=<span class="number">-1</span>;</span><br><span class="line">    pfds[++pos].fd = <span class="number">0</span>;</span><br><span class="line">    pfds[pos].events = POLLIN;</span><br><span class="line">    pfds[++pos].fd = <span class="number">3</span>;</span><br><span class="line">    pfds[pos].events = POLLIN;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="type">int</span> ret = poll(pfds, <span class="number">2</span>, <span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"timeout\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= pos; i++) {</span><br><span class="line">            <span class="keyword">if</span> (pfds[i].revents &amp; POLLIN) {</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">                    fgets(buf1, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"buf1=%s"</span>, buf1);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) {</span><br><span class="line">                    read(fd, buf2, <span class="number">64</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d -- %d -- %d\n"</span>, buf2[<span class="number">0</span>], buf2[<span class="number">1</span>], buf2[<span class="number">2</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>以上示例代码中，我们使用<code>poll</code>函数等待标准输入上的读事件，并设置了一个5秒钟的超时时间。如果超时，程序会输出”Timeout!”，如果有读事件发生，程序会读取标准输入的内容并输出。</p>
</blockquote>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p><code>epoll</code>是Linux内核提供的一种高效的I/O多路复用机制，可以用于在大量并发连接中监视多个文件描述符的I/O事件，比传统的<code>select</code>和<code>poll</code>函数更高效。</p>
<p><code>epoll</code>基于事件驱动模型，只有在需要进行I/O操作时才会阻塞进程，避免了遍历整个文件描述符集合的开销，因此在大量并发连接的场景中，<code>epoll</code>比<code>select</code>和<code>poll</code>更高效。</p>
<p><code>epoll</code>主要包括三个函数：</p>
<p><code>epoll_create()</code>函数用于创建一个新的<code>epoll</code>实例，并返回一个新的文件描述符，用于操作该实例。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">	参数`size`是一个正整数，指定`epoll`实例内部用于存储文件描述符的数量。这个参数在Linux <span class="number">2.6</span><span class="number">.8</span>以后已经不再使用，但是必须传递一个大于<span class="number">0</span>的值。</span><br><span class="line">	返回值为新创建的`epoll`实例的文件描述符，如果出错返回<span class="number">-1</span>。</span><br></pre></td></tr></tbody></table></figure>



<p><code>epoll_ctl()</code>函数用于向<code>epoll</code>实例中添加、修改或删除文件描述符。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">参数`epfd`是`epoll`实例的文件描述符，</span><br><span class="line">    `op`指定操作类型，可以是</span><br><span class="line">        EPOLL_CTL_ADD</span><br><span class="line">        EPOLL_CTL_MOD</span><br><span class="line">        EPOLL_CTL_DEL</span><br><span class="line">    	三个值之一，分别表示添加、修改、删除文件描述符。</span><br><span class="line">    `fd`是要添加、修改或删除的文件描述符，</span><br><span class="line">    `event`是一个指向`epoll_event`结构体的指针，用于指定要监视的事件类型和回调函数。</span><br><span class="line">    返回值为<span class="number">0</span>表示成功，<span class="number">-1</span>表示出错。</span><br></pre></td></tr></tbody></table></figure>

<p><code>epoll_event</code>结构体定义如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct epoll_event {</span><br><span class="line">    uint32_t events;   // 监视的事件类型，可以是 EPOLLIN、EPOLLOUT 等</span><br><span class="line">    epoll_data_t data; // 回调函数中的数据，可以是一个指针或者一个文件描述符</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">其中，`events`成员指定要监视的事件类型，可以是以下值之一：</span><br><span class="line">- `EPOLLIN`：表示文件描述符可读；</span><br><span class="line">- `EPOLLOUT`：表示文件描述符可写；</span><br><span class="line">- `EPOLLPRI`：表示文件描述符有紧急数据可读；</span><br><span class="line">- `EPOLLERR`：表示文件描述符发生错误；</span><br><span class="line">- `EPOLLHUP`：表示文件描述符被挂起；</span><br><span class="line">- `EPOLLRDHUP`：表示TCP连接被对端关闭或重置。</span><br><span class="line"></span><br><span class="line">`data`成员指定回调函数中的数据，可以是一个指针或者一个文件描述符，具体取决于回调函数的实现。</span><br></pre></td></tr></tbody></table></figure>



<p><code>epoll_wait()</code>函数用于等待文件描述符上的I/O事件，并将就绪的文件描述符集合返回给应用程序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event events[], <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	参数`epfd`是`epoll`实例的文件描述符，</span><br><span class="line">        `events[]`是一个指向`epoll_event`结构体数组的指针，用于返回就绪的文件描述符集合.。</span><br><span class="line">        `maxevents`指定返回的最大事件数，</span><br><span class="line">        `timeout`指定等待的超时时间（毫秒），如果为<span class="number">-1</span>表示永久等待，如果为<span class="number">0</span>表示立即返回。 </span><br><span class="line">	返回值为就绪的文件描述符数目，如果超时返回<span class="number">0</span>，如果出错返回<span class="number">-1</span>。 </span><br></pre></td></tr></tbody></table></figure>

<p>在使用<code>epoll</code>时，一般的步骤是： </p>
<ol>
<li>调用<code>epoll_create()</code>函数创建一个<code>epoll</code>实例，并得到一个文件描述符。 </li>
<li>使用<code>epoll_ctl()</code>函数将需要监视的文件描述符添加到<code>epoll</code>实例中，并指定监视的事件类型和回调函数。</li>
<li>使用<code>epoll_wait()</code>函数等待文件描述符上的I/O事件，并处理就绪的文件描述符集合。</li>
<li>重复第3步直到不再需要监视这些文件描述符。</li>
</ol>
<p>需要注意的是，<code>epoll</code>实例内部维护了一个事件表，用于存储要监视的文件描述符和回调函数，因此在添加、修改和删除文件描述符时，需要使用<code>epoll_ctl()</code>函数更新事件表中的数据。同时，使用<code>epoll_wait()</code>函数等待就绪的事件时，需要预先分配一个足够大的<code>epoll_event</code>结构体数组，以便返回就绪的文件描述符集合。</p>
<h4 id="4、异步IO"><a href="#4、异步IO" class="headerlink" title="4、异步IO"></a>4、异步IO</h4><blockquote>
<p>异步IO模型是指进程发起一个IO操作后，立即返回并继续执行其他操作，当IO操作完成后，内核会通知进程。这种模型的优点是可以避免浪费CPU资源，因为IO操作在内核中执行，不需要占用进程的CPU资源，缺点是实现较为复杂，需要操作系统提供异步IO接口支持。</p>
</blockquote>
<h3 id="套接字属性设置"><a href="#套接字属性设置" class="headerlink" title="套接字属性设置"></a>套接字属性设置</h3><h4 id="1、获取和设置套接字属性"><a href="#1、获取和设置套接字属性" class="headerlink" title="1、获取和设置套接字属性"></a>1、获取和设置套接字属性</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br><span class="line">  	参数：</span><br><span class="line">  		sockfd：套接字</span><br><span class="line">  		level：</span><br><span class="line">  			SOL_SOCKET: 通用套接字层</span><br><span class="line">  			IPPROTO_IP： IP层</span><br><span class="line">  			IPPROTO_TCP： TCP层</span><br><span class="line">  		optname:</span><br><span class="line">  			套接字属性设置对应的功能选项，一般填对应宏</span><br><span class="line">  		optval：</span><br><span class="line">  			获取套接字属性对应的值的地址</span><br><span class="line">  		optlen：</span><br><span class="line">  			optval值的长度的地址</span><br><span class="line">                </span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">设置属性表：level     </span><br><span class="line">						SOL_SOCKET</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">参数optname		宏的作用  		 对应参数optval的类型</span><br><span class="line">SO_BROADCAST   	  允许发送广播数据         int</span><br><span class="line">SO_DEBUG			循序调试			  int</span><br><span class="line">SO_DONTROUTE	    不查找路由			 int</span><br><span class="line">SO_ERROR			获的套接字错误			int</span><br><span class="line">SO_KEEPALIVE		保持连接			  int</span><br><span class="line">SO_LINGER			延迟关闭连接			struct linger</span><br><span class="line">SO_OOBINLINE		带外数据放入正常数据流  int</span><br><span class="line">SO_RCVBUF		    接收缓冲区大小			int</span><br><span class="line">SO_SNDBUF			发送缓冲区大小			int</span><br><span class="line">SO_RCVLOWAT			接收缓冲区下限			int</span><br><span class="line">SO_SNDWAIT			发送缓冲区下限			int</span><br><span class="line">SO_RCVTIMEO			接收超时				struct timeval</span><br><span class="line">SO_SNDTIMEO			发送超时				struct timeval</span><br><span class="line">SO_REUSEADDR		允许重用本机地址和端口	int</span><br><span class="line">SO_TYPE				获得套接字类型			int</span><br><span class="line">SO_BSDCOMPAT		与BSD系统兼容			int	</span><br><span class="line">===================================================</span><br><span class="line"></span><br><span class="line">						IPPROTO_IP</span><br><span class="line">------------------------------------------------------</span><br><span class="line">IP_ADD_MEMBERSHIP    加入到组播组中               struct ip_mreq </span><br><span class="line">IP_MULTICAST_IF      允许开启组播报文的接口       struct ip_mreq	</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2、超时检测"><a href="#2、超时检测" class="headerlink" title="2、超时检测"></a>2、超时检测</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1、使用alarm信号和signal函数实现超时检测</span></span><br><span class="line">	alarm(<span class="number">10</span>);</span><br><span class="line">	signal(<span class="number">14</span>, func)；</span><br><span class="line">    </span><br><span class="line">   	<span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//功能实现;</span></span><br><span class="line">    }</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2、IO多路复用select、poll、epoll通过设置函数中的参数 timeout实现</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">mt</span> =</span> {<span class="number">5</span>, <span class="number">0</span>};	</span><br><span class="line">	select(maxfd, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;mt);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、通过设置套接字属性完成超时检测</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">mt</span> =</span> {<span class="number">5</span>, <span class="number">0</span>};	</span><br><span class="line">	<span class="type">int</span> len = <span class="keyword">sizeof</span>(mt);</span><br><span class="line">	setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;mt, len);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment">  &gt; File Name: setsockopt_sever.c</span></span><br><span class="line"><span class="comment">  &gt; Author: yzy</span></span><br><span class="line"><span class="comment">  &gt; blog: miaobuyi.github.io</span></span><br><span class="line"><span class="comment">  &gt; Created Time: 2023年04月14日 星期五 19时12分50秒</span></span><br><span class="line"><span class="comment">  &gt; Modified Time:2023年04月14日 星期五 19时12分50秒</span></span><br><span class="line"><span class="comment"> *******************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> {</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> optval =<span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="type">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line">    <span class="type">int</span> ret = bind(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, s_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bind success\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listen(sockfd, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wait client......\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    timeout.tv_sec = <span class="number">5</span>; <span class="comment">// 设置超时时间为5秒</span></span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">        <span class="type">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line">        <span class="type">int</span> connfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;caddr, &amp;c_len);</span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"accept"</span>);</span><br><span class="line">            <span class="comment">//exit(-1);</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"link success\n"</span>);</span><br><span class="line">        }</span><br><span class="line">        ret = setsockopt(connfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, <span class="keyword">sizeof</span>(timeout));</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"setsockopt"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">            <span class="type">int</span> len = recv(connfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (len &lt; <span class="number">0</span>) {</span><br><span class="line">                perror(<span class="string">"recv"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recv:%s"</span>, buf);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"socket:%d--close\n"</span>, connfd);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="3、广播和组播"><a href="#3、广播和组播" class="headerlink" title="3、广播和组播"></a>3、广播和组播</h4><h3 id="域套接字-–-本地套接字通信"><a href="#域套接字-–-本地套接字通信" class="headerlink" title="域套接字 – 本地套接字通信"></a>域套接字 – 本地套接字通信</h3><p>​	tcp:</p>
<p>​		服务器：</p>
<p>​			socket () –&gt;  bind() –&gt; listen() –&gt; accept() –&gt; read()/write() –&gt; close()</p>
<p>​		客户端：</p>
<p>​			socket () –&gt;  connect() –&gt; read()/write() –&gt; close()</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">socket(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">AF_UNIX对应的地址结构:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> {</span></span><br><span class="line">    <span class="type">sa_family_t</span> sun_family;  <span class="comment">// 地址族类型，必须是 AF_UNIX</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];      <span class="comment">// 套接字文件路径</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>其中，<code>sun_family</code> 成员必须设置为 <code>AF_UNIX</code>，<code>sun_path</code> 成员指定了套接字文件在文件系统中的路径。通常情况下，该路径以一个斜杠（/）开始，以确保该路径是绝对路径，而不是相对路径。而 <code>sun_path</code> 的长度为 <code>108</code>，这是因为在某些系统上，该字段的最大长度为 <code>108</code> 个字符。</p>
<p>需要注意的是，对于 AF_UNIX 套接字，虽然客户端和服务器都需要指定套接字文件路径，但是它们指定的路径是可以不同的。客户端和服务器都需要绑定到一个套接字文件上，并监听该套接字，从而能够相互通信。</p>
<p>服务器</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*===============================================</span></span><br><span class="line"><span class="comment">*   文件名称：server.c</span></span><br><span class="line"><span class="comment">*   创 建 者：     </span></span><br><span class="line"><span class="comment">*   创建日期：2023年04月11日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">================================================*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">{ </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socket success!\n"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    int opt = 1;</span></span><br><span class="line"><span class="comment">    int opt_len = sizeof(int);</span></span><br><span class="line"><span class="comment">    if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, opt_len) &lt; 0)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        perror("setsockopt");</span></span><br><span class="line"><span class="comment">        exit(-1);</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="comment">//saddr.sin_addr.s_addr = inet_addr("192.168.12.15");//将点分十进制转换为整形再赋值</span></span><br><span class="line">    <span class="built_in">strcpy</span>(saddr.sun_path, <span class="string">"mysocket"</span>);</span><br><span class="line">    <span class="type">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bind success!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、设置监听套接字</span></span><br><span class="line">    ret = listen(sockfd, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listen success!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、等待客户端连接</span></span><br><span class="line">    <span class="comment">//struct sockaddr_in caddr;</span></span><br><span class="line">    <span class="comment">//memset(&amp;caddr, 0, sizeof(caddr));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int c_len = sizeof(caddr);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wait for a new client...\n"</span>);</span><br><span class="line">    <span class="type">int</span> connfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"accept"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、接收数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {   </span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">        ret = read(connfd, buf, <span class="number">64</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            perror(<span class="string">"read"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"client leave!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv %dbytes: %s\n"</span>, ret, buf);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    close(connfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>客户端</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*===============================================</span></span><br><span class="line"><span class="comment">*   文件名称：client.c</span></span><br><span class="line"><span class="comment">*   创 建 者：     </span></span><br><span class="line"><span class="comment">*   创建日期：2023年04月11日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">================================================*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">{ </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socket success!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(saddr.sun_path, <span class="string">"mysocket"</span>);</span><br><span class="line">    <span class="type">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"link success!\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、接收数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        fgets(buf, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>SQLite3还提供了许多其他有用的命令。以下是一些常用的命令：</p>
<ol>
<li><p>.mode 命令可以用于设置输出模式，常用的模式有列模式（column）、列表模式（list）和 CSV 模式（csv）等。</p>
</li>
<li><p>.headers on/off 可以用于开启或关闭列头，方便查看查询结果。</p>
</li>
<li><p>.tables 可以用于查看数据库中所有表的名称。</p>
</li>
<li><p>.schema 表名 可以用于查看指定表的结构，包括列名称、数据类型和约束等。</p>
</li>
<li><p>.backup 文件名 可以用于将数据库备份到指定的文件中。</p>
</li>
<li><p>.restore 文件名 可以用于从指定的备份文件中还原数据库。</p>
</li>
<li><p>.dump 可以用于将整个数据库导出为 SQL 语句，方便备份或迁移。</p>
</li>
<li><p>.exit 可以用于退出 SQLite3。</p>
</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mycallback</span><span class="params">( <span class="type">void</span> * para ,<span class="type">int</span> f_num ,<span class="type">char</span> **f_value,<span class="type">char</span> **f_name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    sqlite3 * db;</span><br><span class="line">    <span class="type">char</span> * errmsg;</span><br><span class="line">    <span class="type">int</span> ret = sqlite3_open(<span class="string">"my.db"</span>,&amp;db);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error:%s\n"</span>,sqlite3_errmsg(db));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open ok\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>  sql[<span class="number">1024</span>]={<span class="number">0</span>};</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">"create table login(num char,pass char);"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line"><span class="comment">//    if(sqlite3_exec(db,sql,NULL,NULL,&amp;errmsg)!=0){</span></span><br><span class="line"><span class="comment">//        printf("create:%s\n",errmsg);</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line">    <span class="type">char</span> num[<span class="number">64</span>]={<span class="string">"111111"</span>};</span><br><span class="line">    <span class="type">char</span> pass[<span class="number">64</span>]={<span class="string">"222222"</span>};</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">"insert into login values('%s','%s');"</span>,num,pass);</span><br><span class="line">    <span class="keyword">if</span>(sqlite3_exec(db,sql,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;errmsg)!=<span class="number">0</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"insert:%s\n"</span>,errmsg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(sql,<span class="number">0</span>,<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">"select * from login;"</span>);</span><br><span class="line">    <span class="keyword">if</span>(sqlite3_exec(db,sql,mycallback,<span class="literal">NULL</span>,&amp;errmsg)!=<span class="number">0</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select:%s\n"</span>,errmsg);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    sqlite3_close(db);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mycallback</span><span class="params">( <span class="type">void</span> * para ,<span class="type">int</span> f_num ,<span class="type">char</span> **f_value,<span class="type">char</span> **f_name)</span>{</span><br><span class="line">    <span class="type">int</span> num =f_num;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%16s  "</span>,f_name[i]);</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%16s  "</span>,f_value[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://miaobuyi.github.io">miaobuyi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://miaobuyi.github.io/2023/04/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">https://miaobuyi.github.io/2023/04/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://miaobuyi.github.io" target="_blank">miaobuyi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post_share"><div class="social-share" data-image="https://imgapi.xl0408.top/index.php" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/17/vim%E6%A8%A1%E6%9D%BF/" title="vim模板"><img class="cover" src="https://api.yimian.xyz/img" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">vim模板</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/02/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91/" title="静态库和动态库的编译"><img class="cover" src="https://api.yimian.xyz/img" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">静态库和动态库的编译</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-1307795383.cos.ap-chengdu.myqcloud.com/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">miaobuyi</div><div class="author-info__description">人类的悲欢并不相通</br>我只觉得他们吵闹</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/miaobuyi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/miaobuyi" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2426012846@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Internet%E5%8E%86%E5%8F%B2"><span class="toc-text">Internet历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B"><span class="toc-text">网络协议模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B-%E7%90%86%E8%AE%BA%E5%8C%96%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-text">1、OSI七层协议模型(理论化的模型)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81TCP-x2F-IP%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B"><span class="toc-text">2、TCP&#x2F;IP四层协议模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-text">网络编程预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81IP%E5%9C%B0%E5%9D%80"><span class="toc-text">1、IP地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81PORT%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">2、PORT端口号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97-%E2%80%93socket"><span class="toc-text">3、套接字 –socket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">基于TCP的套接字通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88socket%EF%BC%89"><span class="toc-text">1、创建套接字（socket）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%91%BD%E5%90%8D%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%81%E7%BB%91%E5%AE%9A%EF%BC%88bind%EF%BC%89"><span class="toc-text">2、命名套接字、绑定（bind）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E7%9B%91%E5%90%AC%E9%98%9F%E5%88%97%EF%BC%88listen%EF%BC%89"><span class="toc-text">3、创建监听队列（listen）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5%EF%BC%88accept%EF%BC%89"><span class="toc-text">4、接受连接（accept）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-text">5、读写数据</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#recv"><span class="toc-text">recv</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#send"><span class="toc-text">send</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">6、关闭连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">服务端代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">1、创建套接字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%A1%AB%E5%86%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">2、填写服务器地址结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">3、连接服务器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-text">4、读写数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">5、关闭连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">客户端代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">基于UDP的套接字通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97-1"><span class="toc-text">1、创建套接字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%BB%91%E5%AE%9Aip%E5%9C%B0%E5%9D%80%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">2、绑定ip地址端口号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%8E%A5%E6%94%B6%EF%BC%8C%E5%8F%91%E9%80%81"><span class="toc-text">3、接收，发送</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#sendto"><span class="toc-text">sendto</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#recvform"><span class="toc-text">recvform</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">4、关闭连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">服务器模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%BE%AA%E7%8E%AF%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">1、循环服务器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">2、并发服务器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81TCP%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-text">3、TCP通信的三次握手过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-text">4、四次挥手过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ntohs"><span class="toc-text">ntohs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ntohl"><span class="toc-text">ntohl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#htons"><span class="toc-text">htons</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#htonl"><span class="toc-text">htonl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inet-addr"><span class="toc-text">inet_addr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inet-ntoa"><span class="toc-text">inet_ntoa</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inet-aton"><span class="toc-text">inet_aton</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">字节序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="toc-text">IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%98%BB%E5%A1%9EIO"><span class="toc-text">1、阻塞IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-text">2、非阻塞IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">3、IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#select"><span class="toc-text">select</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#poll"><span class="toc-text">poll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll"><span class="toc-text">epoll</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BC%82%E6%AD%A5IO"><span class="toc-text">4、异步IO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE"><span class="toc-text">套接字属性设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%A5%97%E6%8E%A5%E5%AD%97%E5%B1%9E%E6%80%A7"><span class="toc-text">1、获取和设置套接字属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%B6%85%E6%97%B6%E6%A3%80%E6%B5%8B"><span class="toc-text">2、超时检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%B9%BF%E6%92%AD%E5%92%8C%E7%BB%84%E6%92%AD"><span class="toc-text">3、广播和组播</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97-%E2%80%93-%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1"><span class="toc-text">域套接字 – 本地套接字通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">数据库</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/15/ARM%E6%9E%B6%E6%9E%84/" title="ARM架构"><img src="https://api.yimian.xyz/img" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM架构"/></a><div class="content"><a class="title" href="/2023/05/15/ARM%E6%9E%B6%E6%9E%84/" title="ARM架构">ARM架构</a><time datetime="2023-05-15T01:05:32.000Z" title="发表于 2023-05-15 09:05:32">2023-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/05/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img src="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题"/></a><div class="content"><a class="title" href="/2023/05/05/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a><time datetime="2023-05-05T14:21:30.000Z" title="发表于 2023-05-05 22:21:30">2023-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/04/QT/" title="QT"><img src="https://api.yimian.xyz/img" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QT"/></a><div class="content"><a class="title" href="/2023/05/04/QT/" title="QT">QT</a><time datetime="2023-05-04T09:12:32.000Z" title="发表于 2023-05-04 17:12:32">2023-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/19/C++/" title="C++"><img src="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++"/></a><div class="content"><a class="title" href="/2023/04/19/C++/" title="C++">C++</a><time datetime="2023-04-19T11:20:40.000Z" title="发表于 2023-04-19 19:20:40">2023-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/vim%E6%A8%A1%E6%9D%BF/" title="vim模板"><img src="https://api.yimian.xyz/img" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vim模板"/></a><div class="content"><a class="title" href="/2023/04/17/vim%E6%A8%A1%E6%9D%BF/" title="vim模板">vim模板</a><time datetime="2023-04-17T02:41:45.000Z" title="发表于 2023-04-17 10:41:45">2023-04-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://imgapi.xl0408.top/index.php')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By miaobuyi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><div class="aplayer no-destroy" data-id="5463524537" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><script defer src="https://rmt.dogedoge.com/fetch/~/source/jsdelivr/npm/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/gh/sirxemic/jquery.ripples/dist/jquery.ripples.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>