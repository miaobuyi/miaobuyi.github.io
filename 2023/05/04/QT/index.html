<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>QT | miaobuyi</title><meta name="author" content="miaobuyi"><meta name="copyright" content="miaobuyi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础三个工具​		qmake:Makefile生成器 将 *.pro文件 生成 对应平台下的Makefile​		uic:将 ui(xml)文件转换成c++代码​		moc:元对象编译器 将qt关键字 signals&#x2F;slots转换成c++代码 支持信号与 创建工程​	pro:工程文件 功能：指导生成Makefile  qmake​	widget.h: 窗体类的定义​	widget.cpp:类中成">
<meta property="og:type" content="article">
<meta property="og:title" content="QT">
<meta property="og:url" content="https://miaobuyi.github.io/2023/05/04/QT/index.html">
<meta property="og:site_name" content="miaobuyi">
<meta property="og:description" content="基础三个工具​		qmake:Makefile生成器 将 *.pro文件 生成 对应平台下的Makefile​		uic:将 ui(xml)文件转换成c++代码​		moc:元对象编译器 将qt关键字 signals&#x2F;slots转换成c++代码 支持信号与 创建工程​	pro:工程文件 功能：指导生成Makefile  qmake​	widget.h: 窗体类的定义​	widget.cpp:类中成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.yimian.xyz/img">
<meta property="article:published_time" content="2023-05-04T09:12:32.000Z">
<meta property="article:modified_time" content="2023-05-14T13:25:34.451Z">
<meta property="article:author" content="miaobuyi">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.yimian.xyz/img"><link rel="shortcut icon" href="https://typora-1307795383.cos.ap-chengdu.myqcloud.com/avatar.jpg"><link rel="canonical" href="https://miaobuyi.github.io/2023/05/04/QT/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'QT',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-14 21:25:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-1307795383.cos.ap-chengdu.myqcloud.com/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.yimian.xyz/img')"><nav id="nav"><span id="blog-info"><a href="/" title="miaobuyi"><span class="site-name">miaobuyi</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">QT</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-04T09:12:32.000Z" title="发表于 2023-05-04 17:12:32">2023-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-14T13:25:34.451Z" title="更新于 2023-05-14 21:25:34">2023-05-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="QT"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="三个工具"><a href="#三个工具" class="headerlink" title="三个工具"></a>三个工具</h3><p>​		qmake:Makefile生成器 将 *.pro文件 生成 对应平台下的Makefile<br>​		uic:将 ui(xml)文件转换成c++代码<br>​		moc:元对象编译器 将qt关键字 signals/slots转换成c++代码 支持信号与</p>
<h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>​	pro:工程文件 功能：指导生成Makefile  qmake<br>​	widget.h: 窗体类的定义<br>​	widget.cpp:类中成员函数的定义<br>​	main.cpp:主函数  功能: 定义窗体对象 显示窗体 进入事件循环<br>​	widget.ui(xml): ui文件 uic工具将ui文件转换成c++代码 -&gt; ui_widget.h</p>
<h3 id="qt内存管理"><a href="#qt内存管理" class="headerlink" title="qt内存管理"></a>qt内存管理</h3><p>​	a.所有从QObject继承出来的子对象的内存管理都转移给了父对象<br>​        使用new在堆上分配内存<br>​        子对象可自动被父对象删除内存<br>​        手动删除不会引起二次删除，子对象删除时会通知父对象<br>​    b.没有父对象的对象需要手工删除<br>​    	没有父对象的对象一般分配在栈区，这样可以有效避免内存泄漏<br>​    c.Qt没有自动回收站的机制，需要关注父子关系及其功能</p>
<h2 id="star-信号与槽机制"><a href="#star-信号与槽机制" class="headerlink" title=":star:信号与槽机制"></a><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>信号与槽机制</h2><p>信号与槽机制是Qt中一种重要的机制，用于对象间的通信。信号和槽是用来解决对象间通信的，即当一个对象的某个状态发生改变时，该对象会向其他对象发出信号，其他对象则根据这个信号来作出相应的动作，这个相应的动作就是调用槽函数。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>​	有许多预定义好的信号可以使用</p>
<ul>
<li><code>clicked()</code>：当用户单击鼠标左键按下并释放按钮时发射。</li>
<li><code>pressed()</code>：当用户按下鼠标左键按钮时发射。</li>
<li><code>released()</code>：当用户释放鼠标左键按钮时发射。</li>
<li><code>textChanged(const QString &amp;text)</code>：当文本编辑框中的文本发生更改时发射，并将当前文本作为参数传递给槽函数。</li>
<li><code>valueChanged(int value)</code>：当值更改时，例如 QScrollBar 或 QSlider 控件的值更改时，发射，并将新值作为参数传递给槽函数。</li>
</ul>
<h3 id="槽函数"><a href="#槽函数" class="headerlink" title="槽函数"></a>槽函数</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">slots: <span class="comment">//槽函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Myslots</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		......</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="关联信号与槽函数"><a href="#关联信号与槽函数" class="headerlink" title="关联信号与槽函数"></a>关联信号与槽函数</h3><blockquote>
<p>注意:参数个数：信号参数个数 &gt;= 槽函数的参数个数<br>        参数类型:匹配</p>
</blockquote>
<ol>
<li>通过QObject::connect函数进行关联，connect函数的参数包括信号发射者、信号、槽函数接受者和槽函数。</li>
<li>在Qt Designer中使用Qt信号与槽编辑器进行关联，可以通过视图中的右键菜单或者在对象属性编辑器中的信号/槽标签中进行设置。</li>
<li>通过QAction的triggered()信号和QMenu的aboutToShow()信号，可以直接在代码中将动作与函数关联。</li>
<li>在Qt Quick中，可以使用信号绑定语法来关联信号与槽函数，例如在QML中使用onClicked: function() { … }。</li>
</ol>
<p>需要注意的是，无论使用哪种方式，关联的信号和槽函数的参数类型和数量必须一致，否则会编译错误或者运行时出错。</p>
<p>conect关联 通用</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">{</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接信号和槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui.pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::on_pushButton_clicked);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 处理按钮单击事件</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在信号与槽机制中，信号的参数个数并不一定要大于槽函数的参数个数。事实上，信号与槽之间的参数传递可以有以下几种情况：</p>
<ol>
<li>信号与槽的参数个数一致，类型相同；</li>
<li>信号与槽的参数个数一致，类型不同，但可以进行隐式转换；</li>
<li>信号与槽的参数个数不一致，但信号的参数可以通过默认值或者重载函数的方式不传递参数；</li>
<li>信号与槽的参数个数不一致，但信号的参数可以通过QVariant类型进行传递。</li>
</ol>
<p>因此，信号与槽之间的参数个数和类型关系可以灵活设置，不必非得信号的参数个数大于槽函数的参数个数。</p>
</blockquote>
<h3 id="自定义信号和槽函数"><a href="#自定义信号和槽函数" class="headerlink" title="自定义信号和槽函数"></a>自定义信号和槽函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject {</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(QObject *parent = <span class="literal">nullptr</span>) : <span class="built_in">QObject</span>(parent) {}</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// 定义自定义信号，该信号不带参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义自定义信号，该信号带有一个int类型参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignalWithParam</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">// 定义槽函数，该函数响应mySignal信号，不带参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMySignal</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"My signal is emitted."</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义槽函数，该函数响应mySignalWithParam信号，带有一个int类型参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMySignalWithParam</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"My signal with param is emitted. Param value is "</span> &lt;&lt; value;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，<code>MyClass</code>是一个QObject派生类，它定义了两个自定义信号和两个槽函数。其中，<code>mySignal</code>信号和<code>onMySignal</code>槽函数都不带参数，而<code>mySignalWithParam</code>信号带有一个int类型参数，<code>onMySignalWithParam</code>槽函数也带有一个int类型参数。当<code>mySignal</code>信号被发射时，<code>onMySignal</code>槽函数会被自动调用，而当<code>mySignalWithParam</code>信号被发射时，<code>onMySignalWithParam</code>槽函数会被自动调用，并将参数值传递给该槽函数。</p>
<p>自定义信号可以使用 <code>emit</code> 关键字来发送。在发射信号时，可以将信号的参数传递给槽函数。示例代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义信号</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发射信号</span></span><br><span class="line"><span class="function">emit <span class="title">mySignal</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>这里定义了一个名为 <code>mySignal</code> 的信号，它带有一个整数参数。在需要发射信号的时候，使用 <code>emit</code> 关键字来发射信号，并将信号参数传递给槽函数。</p>
<p>请注意，自定义信号只有在定义了之后才能使用。另外，自定义信号的参数可以是任意类型，包括用户定义的类型，只要这些类型可以被 Qt 的元对象系统所支持即可。</p>
<h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">//1.QPushButton组件</span></span><br><span class="line">    <span class="comment">//2.QToolButton组件</span></span><br><span class="line">    ui-&gt;toolButton-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">"E:/230301/day2/demo1/QQ.ico"</span>));<span class="comment">//设置图标 E:\\230301\\day2\\demo1\\QQ.ico</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.QLineEdit组件</span></span><br><span class="line">    ui-&gt;lineEdit-&gt;<span class="built_in">setText</span>(<span class="string">"aaaaaa"</span>);<span class="comment">//设置文本</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; ui-&gt;lineEdit-&gt;<span class="built_in">text</span>();<span class="comment">//获取文本</span></span><br><span class="line"></span><br><span class="line">    ui-&gt;lineEdit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::Password);<span class="comment">//设置回显方式:密码方式</span></span><br><span class="line">    ui-&gt;lineEdit-&gt;<span class="built_in">setMaxLength</span>(<span class="number">8</span>);<span class="comment">//设置最大长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.QLabel组件</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setText</span>(<span class="string">"zzzz"</span>);<span class="comment">//设置文本</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; ui-&gt;label-&gt;<span class="built_in">text</span>();<span class="comment">//获取文本</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setFont</span>(<span class="built_in">QFont</span>(<span class="string">"Arial"</span>));<span class="comment">//设置字体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//label显示图片</span></span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">    pixmap.<span class="built_in">load</span>(<span class="string">"E:/230301/day2/demo1/QQ.ico"</span>);<span class="comment">//加载图片</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setPixmap</span>(pixmap);<span class="comment">//显示图片</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);<span class="comment">//内容自适应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.QListWidget组件</span></span><br><span class="line">    ui-&gt;listWidget-&gt;<span class="built_in">addItem</span>(<span class="string">"ccc"</span>);<span class="comment">//动态添加列表项</span></span><br><span class="line">    ui-&gt;listWidget-&gt;<span class="built_in">addItem</span>(<span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="built_in">QIcon</span>(<span class="string">":/images/QQ.ico"</span>),<span class="string">"ddd"</span>));<span class="comment">//资源文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.Group Box 分组框 组件</span></span><br><span class="line">    <span class="comment">//7.QFrame组件</span></span><br><span class="line">    ui-&gt;frame-&gt;<span class="built_in">setAutoFillBackground</span>(<span class="literal">true</span>);<span class="comment">//自动填充背景</span></span><br><span class="line">    ui-&gt;frame-&gt;<span class="built_in">setPalette</span>(<span class="built_in">QPalette</span>(Qt::red));<span class="comment">//设置调色板</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.QCombo Box组件(下拉列表)</span></span><br><span class="line">    ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">"广州"</span>);<span class="comment">//动态添加item</span></span><br><span class="line">    ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">"深圳"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//10.QSpinBox</span></span><br><span class="line">    ui-&gt;spinBox-&gt;<span class="built_in">setValue</span>(<span class="number">1</span>);<span class="comment">//设置value值</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; ui-&gt;spinBox-&gt;<span class="built_in">value</span>();<span class="comment">//获取value值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span><span class="comment">//1.QPushButton</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="comment">//灯亮</span></span><br><span class="line">    {</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="string">"ON"</span>);<span class="comment">//设置文本</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//灯灭</span></span><br><span class="line">    {</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="string">"OFF"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_pressed</span><span class="params">()</span><span class="comment">//槽函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"pressed..."</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_released</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">     <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"released..."</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QListWidgetItem *item =  ui-&gt;listWidget-&gt;<span class="built_in">takeItem</span>(ui-&gt;listWidget-&gt;<span class="built_in">currentRow</span>());<span class="comment">//当前选中的item从当前列表中删除</span></span><br><span class="line">    ui-&gt;listWidget_2-&gt;<span class="built_in">addItem</span>(item);<span class="comment">//添加item到列表</span></span><br><span class="line"></span><br><span class="line">    ui-&gt;listWidget-&gt;<span class="built_in">sortItems</span>(Qt::AscendingOrder);<span class="comment">//排序</span></span><br><span class="line">    ui-&gt;listWidget_2-&gt;<span class="built_in">sortItems</span>(Qt::AscendingOrder);<span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_3_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QListWidgetItem *item =  ui-&gt;listWidget_2-&gt;<span class="built_in">takeItem</span>(ui-&gt;listWidget_2-&gt;<span class="built_in">currentRow</span>());<span class="comment">//当前选中的item从当前列表中删除</span></span><br><span class="line">    ui-&gt;listWidget-&gt;<span class="built_in">addItem</span>(item);<span class="comment">//添加item到列表</span></span><br><span class="line"></span><br><span class="line">    ui-&gt;listWidget-&gt;<span class="built_in">sortItems</span>(Qt::AscendingOrder);<span class="comment">//排序</span></span><br><span class="line">    ui-&gt;listWidget_2-&gt;<span class="built_in">sortItems</span>(Qt::AscendingOrder);<span class="comment">//排序</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_checkBox_3_stateChanged</span><span class="params">(<span class="type">int</span> arg1)</span><span class="comment">//槽函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; arg1;</span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;checkBox_3-&gt;<span class="built_in">isChecked</span>())</span><br><span class="line">        ui-&gt;groupBox-&gt;<span class="built_in">setTitle</span>(ui-&gt;groupBox-&gt;<span class="built_in">title</span>()+<span class="string">"A"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ui-&gt;groupBox-&gt;<span class="built_in">setTitle</span>(ui-&gt;groupBox-&gt;<span class="built_in">title</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_comboBox_currentIndexChanged</span><span class="params">(<span class="type">const</span> QString &amp;arg1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; arg1;<span class="comment">//item的文本</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_comboBox_currentIndexChanged</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; index;<span class="comment">//item的下标</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_fontComboBox_currentFontChanged</span><span class="params">(<span class="type">const</span> QFont &amp;f)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ui-&gt;label_3-&gt;<span class="built_in">setFont</span>(f);<span class="comment">//设置字体</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_spinBox_valueChanged</span><span class="params">(<span class="type">int</span> arg1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; arg1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_horizontalSlider_sliderMoved</span><span class="params">(<span class="type">int</span> position)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; position;<span class="comment">//当前滑块位置</span></span><br><span class="line">    ui-&gt;progressBar-&gt;<span class="built_in">setValue</span>(position);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_4_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//打开文件对话框</span></span><br><span class="line">    QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="comment">//父对象</span></span><br><span class="line">                                 <span class="string">"Open File"</span>,<span class="comment">//标题</span></span><br><span class="line">                                 QDir::<span class="built_in">currentPath</span>(),<span class="comment">//当前路径</span></span><br><span class="line">                                 <span class="string">"C++ Source Files(*.cpp *.C *.cc);;Text files (*.txt);;C++ Header Files (*.h)"</span><span class="comment">//过滤项</span></span><br><span class="line">                                 );</span><br><span class="line">    <span class="keyword">if</span>(fileName.<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; fileName;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2D绘图"><a href="#2D绘图" class="headerlink" title="2D绘图"></a>2D绘图</h2><p>使用Qt 2D绘图的基本步骤如下：</p>
<ol>
<li><p>创建QPainter对象，通过QWidget::paintEvent()事件获取QPainter指针。</p>
</li>
<li><p>设置画笔和画刷，以及其他的绘图参数。</p>
</li>
<li><p>绘制各种图形：线段、矩形、圆形、椭圆、多边形等。</p>
</li>
<li><p>使用QPainter::save()和QPainter::restore()函数保存和恢复绘图状态，例如：设置画笔和画刷、旋转、缩放等。</p>
</li>
<li><p>使用QPainter::translate()、QPainter::rotate()、QPainter::scale()等函数进行平移、旋转、缩放等变换。</p>
</li>
<li><p>使用QPainter::drawPixmap()函数绘制图像。</p>
</li>
<li><p>使用QPainter::drawText()函数绘制文本。</p>
</li>
<li><p>在绘图完成后，删除QPainter对象。</p>
</li>
</ol>
<p>常用的绘图函数包括：</p>
<ul>
<li><p>drawLine()：绘制直线。</p>
</li>
<li><p>drawRect()：绘制矩形。</p>
</li>
<li><p>drawEllipse()：绘制椭圆。</p>
</li>
<li><p>drawArc()：绘制弧线。</p>
</li>
<li><p>drawPolygon()：绘制多边形。</p>
</li>
<li><p>drawPixmap()：绘制图像。</p>
</li>
<li><p>drawText()：绘制文本。</p>
</li>
</ul>
<p>QPainter对象的状态可以通过QPainter::save()函数保存，通过QPainter::restore()函数恢复。</p>
<p>旋转、缩放和平移等变换可以使用QPainter::translate()、QPainter::rotate()、QPainter::scale()等函数进行。</p>
<p>在绘图时，可以使用QPen和QBrush对象设置画笔和画刷的样式。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制矩形</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存绘图状态</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转30度</span></span><br><span class="line">    painter.<span class="built_in">rotate</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制矩形</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复绘图状态</span></span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平移</span></span><br><span class="line">    painter.<span class="built_in">translate</span>(<span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩放</span></span><br><span class="line">    painter.<span class="built_in">scale</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制文本</span></span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="string">"Hello, world!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制图像</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">":/image/image.png"</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">10</span>, <span class="number">50</span>, pixmap);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上述示例代码中，我们通过QPainter对象绘制了一个矩形、一个旋转后的矩形、一个缩放和平移后的文本和一个图像。通过使用QPainter::save()和QPainter::restore()函数保存和恢复绘图状态，我们可以在变换之后恢复到原来的状态，而不影响之后的绘图。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>QT提供了多种文件操作的类和方法，以下是一些常用的文件操作知识点：</p>
<ol>
<li><p>QFile类：QFile类提供了一个用于读写文件的抽象概念。常用的方法包括open()、close()、read()、write()、seek()、size()等。</p>
</li>
<li><p>QDir类：QDir类提供了一个表示目录路径的抽象概念。常用的方法包括exists()、mkdir()、rmdir()、entryList()等。</p>
</li>
<li><p>QFileInfo类：QFileInfo类提供了一个用于获取文件信息的抽象概念。常用的方法包括exists()、size()、isDir()、isFile()等。</p>
</li>
<li><p>QTextStream类：QTextStream类提供了一个用于读写文本文件的抽象概念。常用的方法包括setCodec()、readLine()、write()等。</p>
</li>
<li><p>QDataStream类：QDataStream类提供了一个用于读写二进制文件的抽象概念。常用的方法包括setVersion()、readRawData()、writeRawData()等。</p>
</li>
<li><p>QTemporaryFile类：QTemporaryFile类提供了一个用于创建临时文件的抽象概念。常用的方法包括open()、close()、fileName()等。</p>
</li>
<li><p>QFileDevice类：QFileDevice类是QFile、QTemporaryFile、QTcpSocket、QProcess等类的基类，提供了一些共同的方法，如read()、write()、atEnd()等。</p>
</li>
<li><p>QDirIterator类：QDirIterator类提供了一个用于遍历目录的抽象概念。常用的方法包括next()、filePath()等。</p>
</li>
<li><p>QSaveFile类：QSaveFile类提供了一个用于原子写入文件的抽象概念，确保写入过程中不会影响原有文件内容。常用的方法包括open()、commit()、cancelWriting()等。</p>
</li>
</ol>
<p>除了以上类和方法，QT还提供了一些特殊的文件操作类和方法，如QFileSystemWatcher类、QFileSelector类、QStandardPaths类等。开发者可以根据需求选择合适的类和方法进行文件操作。</p>
<blockquote>
<p>QFile是Qt中用于读写文件的类，支持文本文件和二进制文件的读写。可以用QFile读取文本或者二进制文件，并且可以将读取的文件内容写入到另一个文件中，或者在当前文件中追加内容。主要的成员函数包括open()、close()、read()、write()等。</p>
</blockquote>
<blockquote>
<p>QDir是Qt中用于操作文件夹（目录）的类，可以获取文件夹的路径，获取文件夹下的文件列表、子文件夹列表、文件过滤等操作。主要的成员函数包括exists()、mkpath()、rmdir()、entryList()等。</p>
</blockquote>
<blockquote>
<p>QFileInfo是Qt中用于获取文件信息的类，包括文件名、文件路径、文件大小、文件创建时间、文件修改时间等等。主要的成员函数包括exists()、fileName()、size()、created()等。</p>
</blockquote>
<blockquote>
<p>QTextStream是Qt中用于读写文本的类，它提供了逐行读取文本文件的方法，可以对文件进行格式化读写。主要的成员函数包括readLine()、atEnd()、seek()、reset()等。</p>
</blockquote>
<blockquote>
<p>QDataStream是Qt中用于读写二进制文件的类，支持大多数的基本数据类型，包括QString、QByteArray、QDateTime等。主要的成员函数包括readRawData()、writeRawData()、operator&lt;&lt;()、operator&gt;&gt;()等。</p>
</blockquote>
<p>以上这些类是Qt中常用的文件操作类，使用这些类可以方便地进行文件和文件夹的读写操作。</p>
<h2 id="QProcess"><a href="#QProcess" class="headerlink" title="QProcess"></a>QProcess</h2><p><code>QProcess</code>是Qt中用于控制外部进程的类，可以启动外部进程、发送数据给外部进程、读取外部进程输出等。</p>
<p>通过<code>QProcess</code>可以在Qt中方便地使用外部命令、工具等，例如启动命令行窗口、执行系统命令、调用其他应用程序等。同时，<code>QProcess</code>也支持与外部进程进行交互，可以向外部进程发送数据并接收外部进程的输出结果。</p>
<p>使用<code>QProcess</code>需要先创建一个<code>QProcess</code>对象，然后通过<code>start()</code>方法启动外部进程。可以通过<code>setProgram()</code>方法设置要执行的程序，通过<code>setArguments()</code>方法设置程序的参数。还可以设置进程的工作目录、环境变量、启动模式等。启动后，可以通过<code>waitForStarted()</code>等方法判断进程是否启动成功。</p>
<p>通过<code>write()</code>方法可以向外部进程发送数据，通过<code>readyRead()</code>信号和<code>readAll()</code>等方法可以读取外部进程的输出结果。还可以通过<code>terminate()</code>和<code>kill()</code>方法停止外部进程的执行。在程序结束时，需要通过<code>close()</code>方法关闭<code>QProcess</code>对象并释放资源。</p>
<p>下面是一个使用<code>QProcess</code>启动外部命令的例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">QProcess process;</span><br><span class="line">process.<span class="built_in">setProgram</span>(<span class="string">"notepad.exe"</span>);</span><br><span class="line">process.<span class="built_in">start</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码会启动Windows中的记事本应用程序。</p>
<p>需要注意的是，<code>QProcess</code>在启动外部进程时会创建一个新的进程，因此需要一定的时间和资源开销。在使用<code>QProcess</code>时，应尽量避免启动过多的进程或频繁地启动和关闭进程，以免对系统性能造成影响。</p>
<p>要向外部进程发送数据，可以使用进程间通信（Inter-process Communication，IPC）机制。Qt提供了一些类来实现IPC，例如QSharedMemory、QSystemSemaphore、QLocalServer/QLocalSocket、QProcess等。</p>
<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>其中，如果要发送数据给外部进程，可以使用QProcess类。QProcess类可以启动外部程序并与之进行通信，可以向外部进程写入数据，并从外部进程读取数据。</p>
<p>下面是一个简单的示例，展示如何向外部进程发送数据：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个QProcess对象</span></span><br><span class="line">QProcess *process = <span class="keyword">new</span> <span class="built_in">QProcess</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动外部进程</span></span><br><span class="line">process-&gt;<span class="built_in">start</span>(<span class="string">"your_program.exe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待外部进程启动完成</span></span><br><span class="line"><span class="keyword">if</span> (process-&gt;<span class="built_in">waitForStarted</span>()) {</span><br><span class="line">    <span class="comment">// 向外部进程写入数据</span></span><br><span class="line">    <span class="function">QByteArray <span class="title">data</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">    process-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">    process-&gt;<span class="built_in">closeWriteChannel</span>(); <span class="comment">// 必须在写入数据之后关闭写通道</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待外部进程完成</span></span><br><span class="line">    <span class="keyword">if</span> (process-&gt;<span class="built_in">waitForFinished</span>()) {</span><br><span class="line">        <span class="comment">// 从外部进程读取数据</span></span><br><span class="line">        QByteArray result = process-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"received data from external process:"</span> &lt;&lt; result;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"failed to wait for external process to finish"</span>;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"failed to start external process"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是，启动外部进程时可能会耗费一定的时间，所以需要在启动完成之后再向其发送数据。此外，QProcess::waitForStarted()和QProcess::waitForFinished()方法都会阻塞当前线程，需要在非GUI线程中使用，以避免阻塞主线程导致GUI无响应。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是指两个或多个进程共享一个物理内存区域的机制，每个进程都可以访问同一块内存。共享内存是一种高效的进程间通信方式，特别适合大量数据的高速传输。</p>
<p>在Qt中，共享内存可以使用QSharedMemory类来实现。QSharedMemory类封装了共享内存的创建、映射、读写等操作，使用起来比较方便。</p>
<p>下面是一个使用QSharedMemory类实现进程间共享数据的例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Writer进程</span></span><br><span class="line"></span><br><span class="line"><span class="function">QSharedMemory <span class="title">sharedMemory</span><span class="params">(<span class="string">"MySharedMemory"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sharedMemory.<span class="built_in">create</span>(<span class="built_in">sizeof</span>(MyData))) {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Failed to create shared memory"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MyData* data = <span class="built_in">static_cast</span>&lt;MyData*&gt;(sharedMemory.<span class="built_in">data</span>());</span><br><span class="line">data-&gt;x = <span class="number">1</span>;</span><br><span class="line">data-&gt;y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reader进程</span></span><br><span class="line"></span><br><span class="line"><span class="function">QSharedMemory <span class="title">sharedMemory</span><span class="params">(<span class="string">"MySharedMemory"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sharedMemory.<span class="built_in">attach</span>()) {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Failed to attach to shared memory"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MyData* data = <span class="built_in">static_cast</span>&lt;MyData*&gt;(sharedMemory.<span class="built_in">data</span>());</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"x = "</span> &lt;&lt; data-&gt;x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; data-&gt;y;</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，Writer进程创建了一个名为”MySharedMemory”的共享内存，并向其中写入了数据。Reader进程通过attach()函数打开了同一块共享内存，并从中读取了数据。</p>
<p>需要注意的是，在使用共享内存时要保证多个进程对同一块内存的访问顺序和正确性。可以使用互斥锁等机制来实现共享内存的同步和互斥访问。</p>
<p>是的，读取共享内存的时候需要先将共享内存区域映射到进程的地址空间。具体可以使用QSharedMemory的<code>attach()</code>函数来完成映射。代码示例如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">QSharedMemory <span class="title">sharedMemory</span><span class="params">(<span class="string">"mySharedMemory"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (sharedMemory.<span class="built_in">attach</span>()) {</span><br><span class="line">    <span class="comment">// 将共享内存区域映射到进程的地址空间</span></span><br><span class="line">    <span class="type">char</span> *data = (<span class="type">char</span> *)sharedMemory.<span class="built_in">constData</span>();</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    sharedMemory.<span class="built_in">detach</span>();</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 映射失败，处理错误</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，<code>constData()</code>函数返回共享内存区域的首地址，这里将它转换成<code>char*</code>类型。在读取数据时，需要根据实际情况进行解析。最后，调用<code>detach()</code>函数解除共享内存区域和进程地址空间的映射关系。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在 Qt 中使用多线程，有两种方式，一种是继承自 QThread 类，另一种是继承自 QObject 类并使用 moveToThread 函数将该对象移动到新线程中。</p>
<h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p>继承自 QThread 类的方式通常用于比较简单的多线程应用，继承自 QObject 类的方式则适合于更复杂的多线程应用，比如多个线程之间需要相互通信等。</p>
<p>在继承自 QThread 类的方式中，需要实现 run 函数，在该函数中执行线程需要执行的操作。示例代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">{</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyThread</span>(QObject *parent = <span class="literal">nullptr</span>) : <span class="built_in">QThread</span>(parent) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="comment">// 执行线程需要执行的操作</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>当需要启动该线程时，创建该线程对象，并调用 start 函数。如下所示：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">MyThread *thread = <span class="keyword">new</span> <span class="built_in">MyThread</span>(<span class="keyword">this</span>);</span><br><span class="line">thread-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>这里需要注意的是，线程对象的创建和 start 函数的调用都应该在主线程中进行。</p>
<p>在继承自 QObject 类的方式中，首先需要将该对象移动到新线程中，然后再调用 start 函数启动线程。示例代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> : <span class="keyword">public</span> QObject</span><br><span class="line">{</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>(QObject *parent = <span class="literal">nullptr</span>) : <span class="built_in">QObject</span>(parent) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 执行需要在新线程中执行的操作</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主线程中创建 MyObject 对象，并将其移动到新线程中</span></span><br><span class="line">QThread *thread = <span class="keyword">new</span> <span class="built_in">QThread</span>();</span><br><span class="line">MyObject *obj = <span class="keyword">new</span> <span class="built_in">MyObject</span>();</span><br><span class="line">obj-&gt;<span class="built_in">moveToThread</span>(thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">QObject::<span class="built_in">connect</span>(thread, &amp;QThread::started, obj, &amp;MyObject::doWork);</span><br><span class="line">thread-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的示例代码中，MyObject 类中定义了一个名为 doWork 的槽函数，该函数中包含需要在新线程中执行的操作。创建线程对象 thread，将 MyObject 对象 obj 移动到该线程中，并将 doWork 槽函数与线程对象的 started 信号连接起来，从而在线程启动时自动调用 doWork 函数。</p>
<p>需要注意的是，在使用线程进行多线程编程时，需要特别注意线程安全性问题，避免出现多线程竞争的问题，比如资源抢占、数据不一致等。可以使用信号量、互斥锁等机制来保证线程安全性。</p>
<h3 id="moveToThread"><a href="#moveToThread" class="headerlink" title="moveToThread"></a>moveToThread</h3><p><code>moveToThread</code> 是 <code>QObject</code> 类中的一个方法，可以将 <code>QObject</code> 对象移动到另一个线程中执行。</p>
<p>一般来说，在 Qt 中，所有的 GUI 相关操作都必须在主线程中执行，否则容易导致程序崩溃或者表现异常。但是如果某些操作太耗时，就会阻塞主线程，导致界面卡顿或者无响应，这时就需要将耗时操作放到其他线程中执行，而 <code>moveToThread</code> 就是用于将某个对象移动到其他线程中执行的方法。</p>
<p>使用 <code>moveToThread</code> 方法的基本流程如下：</p>
<ol>
<li>创建一个 <code>QObject</code> 子类对象；</li>
<li>创建一个新的线程；</li>
<li>调用 <code>QObject::moveToThread</code> 方法，将对象移动到新线程中；</li>
<li>启动新线程，并在其中执行 <code>QObject</code> 对象的某个方法。</li>
</ol>
<p>具体实现方法可以参考以下示例代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// WorkerThread.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">{</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">progress</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// WorkerObject.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerObject</span> : <span class="keyword">public</span> QObject</span><br><span class="line">{</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新线程</span></span><br><span class="line">    QThread* thread = <span class="keyword">new</span> QThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建工作线程对象</span></span><br><span class="line">    WorkerThread* workerThread = <span class="keyword">new</span> WorkerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将工作线程对象移动到新线程中</span></span><br><span class="line">    workerThread-&gt;<span class="built_in">moveToThread</span>(thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建工作对象</span></span><br><span class="line">    WorkerObject* workerObject = <span class="keyword">new</span> WorkerObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将工作对象的 doWork() 方法与工作线程的 started() 信号关联</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(thread, &amp;QThread::started, workerObject, &amp;WorkerObject::doWork);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将工作对象的 progress() 信号与主线程的槽函数关联</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(workerObject, &amp;WorkerObject::progress, [] (<span class="type">int</span> value) {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Progress:"</span> &lt;&lt; value;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动新线程</span></span><br><span class="line">    thread-&gt;<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// WorkerThread.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerThread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Worker thread started."</span>;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    <span class="function">emit <span class="title">progress</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">// do some more work</span></span><br><span class="line">    <span class="function">emit <span class="title">progress</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="comment">// do even more work</span></span><br><span class="line">    <span class="function">emit <span class="title">progress</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Worker thread finished."</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// WorkerObject.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkerObject::doWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Worker object started."</span>;</span><br><span class="line">    <span class="function">emit <span class="title">progress</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    <span class="function">emit <span class="title">progress</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line">    <span class="comment">// do some more work</span></span><br><span class="line">    <span class="function">emit <span class="title">progress</span><span class="params">(<span class="number">75</span>)</span></span>;</span><br><span class="line">    <span class="comment">// do even more work</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Worker object finished."</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁（mutex）是多线程编程中常用的同步机制，用于保护共享资源的访问。互斥锁只允许一个线程访问受保护的资源，其他线程必须等待直到该线程释放锁。这种机制可以有效避免多个线程同时访问同一资源而导致的数据竞争和结果不可预期的情况。</p>
<p>在C++中，可以使用<code>std::mutex</code>或者<code>QMutex</code>类来实现互斥锁。使用互斥锁的基本流程如下：</p>
<ol>
<li>创建互斥锁对象</li>
<li>在需要保护的代码块前获取锁</li>
<li>访问共享资源</li>
<li>在代码块后释放锁</li>
</ol>
<p>下面是一个使用<code>QMutex</code>的示例代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建互斥锁对象</span></span><br><span class="line">QMutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accessSharedResource</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 在代码块前获取锁</span></span><br><span class="line">    mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 在代码块后释放锁</span></span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是，互斥锁的使用需要注意以下几点：</p>
<ol>
<li>互斥锁只能保护代码块中的共享资源，因此需要将所有需要保护的代码都放在同一个锁中。</li>
<li>获取锁和释放锁的操作必须成对出现，否则会导致死锁或资源泄露等问题。</li>
<li>在使用互斥锁时需要考虑性能问题，过多的锁会影响程序的并发性能。</li>
</ol>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁（QReadWriteLock）是一种用于多线程编程的同步机制，用于在多线程环境下提供读取数据的并发性，同时保证写入数据时的互斥性。</p>
<p>读写锁允许多个线程同时读取数据，但只有一个线程能够写入数据。当一个线程正在写入数据时，其他线程无法读取或写入数据，直到写入操作完成。</p>
<p>读写锁主要有三种锁模式：读锁、写锁和尝试锁。</p>
<ul>
<li>读锁：允许多个线程同时持有读锁，并且在读锁没有被持有的情况下允许获取读锁，但是在写锁被持有时不允许获取读锁。</li>
<li>写锁：只允许一个线程持有写锁，当写锁被持有时不允许获取读锁或写锁。</li>
<li>尝试锁：允许线程尝试获取读锁或写锁，如果获取不到锁，则立即返回false，不会阻塞线程。</li>
</ul>
<blockquote>
<p>Qt提供了QReadWriteLock类来实现读写锁，可以通过lockForRead()、lockForWrite()和tryLockForRead()、tryLockForWrite()方法获取读锁和写锁。同时，也可以通过QReadLocker和QWriteLocker类来简化锁的使用，这两个类封装了锁的获取和释放，使用时更加方便。</p>
</blockquote>
<h2 id="SOCKET"><a href="#SOCKET" class="headerlink" title="SOCKET"></a>SOCKET</h2><h3 id="UDPSOCKET"><a href="#UDPSOCKET" class="headerlink" title="UDPSOCKET"></a>UDPSOCKET</h3><p>UDP Socket 是一种基于无连接的网络协议，数据报是UDP数据包的基本单位，UDP能够实现不可靠的、无序的、尽最大努力的数据传输。在Qt中，可以使用QUdpSocket类来实现UDP协议的通信。通过创建QUdpSocket对象并绑定到本地主机地址和端口号，即可发送和接收UDP数据报。</p>
<p>下面是一个使用QUdpSocket类发送和接收UDP数据报的示例代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建QUdpSocket对象</span></span><br><span class="line">QUdpSocket *udpSocket = <span class="keyword">new</span> <span class="built_in">QUdpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定本地主机地址和端口号</span></span><br><span class="line">udpSocket-&gt;<span class="built_in">bind</span>(QHostAddress::LocalHost, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送UDP数据报</span></span><br><span class="line">QByteArray datagram = <span class="string">"Hello, World!"</span>;</span><br><span class="line">udpSocket-&gt;<span class="built_in">writeDatagram</span>(datagram, QHostAddress::LocalHost, <span class="number">5678</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收UDP数据报</span></span><br><span class="line">QByteArray buffer;</span><br><span class="line">buffer.<span class="built_in">resize</span>(udpSocket-&gt;<span class="built_in">pendingDatagramSize</span>());</span><br><span class="line">udpSocket-&gt;<span class="built_in">readDatagram</span>(buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Received datagram: "</span> &lt;&lt; buffer;</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的示例中，首先创建了一个QUdpSocket对象，并绑定到本地主机地址和端口号。然后，通过调用writeDatagram()方法发送UDP数据报，将数据报发送到目标主机的5678端口。最后，使用readDatagram()方法接收UDP数据报，并将其存储在buffer中。</p>
<h3 id="TCPSOCKET"><a href="#TCPSOCKET" class="headerlink" title="TCPSOCKET"></a>TCPSOCKET</h3><p>TCP（Transmission Control Protocol）是传输控制协议，它是一种面向连接的协议，提供可靠的数据传输。在Qt中，可以使用QTcpSocket类来实现TCP客户端，使用QTcpServer类来实现TCP服务器。</p>
<p>以下是Qt中使用TCP的基本步骤：</p>
<ol>
<li>创建QTcpSocket对象或QTcpServer对象。</li>
<li>为QTcpSocket对象连接信号槽，以便在与服务器连接状态变化时得到通知。</li>
<li>调用QTcpSocket对象的connectToHost()函数或QTcpServer对象的listen()函数连接服务器或启动服务器监听。</li>
<li>当QTcpSocket对象的connected()信号触发时，表示成功连接到服务器。此时可以使用QTcpSocket对象的write()函数向服务器发送数据。</li>
<li>当QTcpSocket对象的readyRead()信号触发时，表示有数据到达。此时可以使用QTcpSocket对象的read()函数读取数据。</li>
<li>当QTcpSocket对象的disconnected()信号触发时，表示与服务器连接已断开。</li>
</ol>
<p>注意事项：</p>
<ol>
<li>在连接前需要调用QTcpSocket对象或QTcpServer对象的setSocketOption()函数来设置socket选项。</li>
<li>在Qt5之前，需要在main函数中使用QCoreApplication::processEvents()函数来触发信号槽连接。</li>
<li>在Qt5之后，建议使用QCoreApplication::exec()函数替代QCoreApplication::processEvents()函数来触发信号槽连接。</li>
</ol>
<p>示例代码：</p>
<ol>
<li>TCP客户端：</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">QTcpSocket *tcpSocket = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(tcpSocket, &amp;QTcpSocket::connected, <span class="keyword">this</span>, [&amp;]() {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Connected to server"</span>;</span><br><span class="line">    tcpSocket-&gt;<span class="built_in">write</span>(<span class="string">"Hello, server"</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(tcpSocket, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, [&amp;]() {</span><br><span class="line">    QByteArray data = tcpSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Received data from server:"</span> &lt;&lt; data;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">tcpSocket-&gt;<span class="built_in">connectToHost</span>(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>TCP服务器：</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">QTcpServer *tcpServer = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(tcpServer, &amp;QTcpServer::newConnection, <span class="keyword">this</span>, [&amp;]() {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"New client connected"</span>;</span><br><span class="line">    QTcpSocket *clientSocket = tcpServer-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">    <span class="built_in">connect</span>(clientSocket, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, [&amp;]() {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Client disconnected"</span>;</span><br><span class="line">        clientSocket-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    });</span><br><span class="line">    <span class="built_in">connect</span>(clientSocket, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, [&amp;]() {</span><br><span class="line">        QByteArray data = clientSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Received data from client:"</span> &lt;&lt; data;</span><br><span class="line">        clientSocket-&gt;<span class="built_in">write</span>(<span class="string">"Hello, client"</span>);</span><br><span class="line">    });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcpServer-&gt;<span class="built_in">listen</span>(QHostAddress::Any, <span class="number">8888</span>)) {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Server started"</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Failed to start server"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>QNetworkAccessManager是一个用于网络访问的类，它提供了一系列函数用于发送和接收网络请求，支持HTTP、FTP、文件下载、文件上传等操作。通过QNetworkAccessManager，可以发起HTTP GET/POST请求，上传和下载文件等操作。</p>
<p>使用QNetworkAccessManager进行网络请求通常需要以下步骤：</p>
<ol>
<li>创建一个QNetworkAccessManager实例，用于管理网络请求；</li>
<li>创建一个QNetworkRequest实例，用于描述请求信息，包括请求的URL、请求头、请求方式等；</li>
<li>发送请求，通常使用QNetworkAccessManager的get()、post()等函数；</li>
<li>处理响应，通常使用QNetworkReply类的信号来获取响应数据。</li>
</ol>
<p>以下是一个使用QNetworkAccessManager进行HTTP GET请求的示例代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtNetwork&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QNetworkAccessManager manager;</span><br><span class="line">    <span class="function">QNetworkRequest <span class="title">request</span><span class="params">(QUrl(<span class="string">"https://www.example.com"</span>))</span></span>;</span><br><span class="line">    QNetworkReply *reply = manager.<span class="built_in">get</span>(request);</span><br><span class="line"></span><br><span class="line">    QObject::<span class="built_in">connect</span>(reply, &amp;QNetworkReply::finished, [&amp;]() {</span><br><span class="line">        <span class="keyword">if</span> (reply-&gt;<span class="built_in">error</span>() == QNetworkReply::NoError) {</span><br><span class="line">            QByteArray data = reply-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; data;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Request failed:"</span> &lt;&lt; reply-&gt;<span class="built_in">errorString</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        reply-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">        a.<span class="built_in">quit</span>();</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，我们首先创建了一个QNetworkAccessManager实例，然后创建了一个QNetworkRequest实例，指定请求的URL为<a target="_blank" rel="noopener" href="https://www.example.com.接着,我们调用manager.get(request)发送请求,并获得一个qnetworkreply实例reply,用于处理响应数据./">https://www.example.com。接着，我们调用manager.get(request)发送请求，并获得一个QNetworkReply实例reply，用于处理响应数据。</a></p>
<p>我们使用QObject::connect()函数将QNetworkReply::finished信号与一个lambda表达式连接，用于在请求完成时获取响应数据。如果请求成功，我们可以使用QNetworkReply::readAll()函数读取响应数据，如果请求失败，我们可以使用QNetworkReply::errorString()函数获取错误信息。最后，我们调用reply-&gt;deleteLater()函数释放QNetworkReply实例，然后调用QCoreApplication::quit()函数退出应用程序。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">{</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;"QSslSocket="&lt;&lt;QSslSocket::sslLibraryBuildVersionString();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建应用获取 key</span></span><br><span class="line">    QString API_Key = <span class="string">"Xokw5o3jf9lwUsqQX7mPzhf9"</span>;</span><br><span class="line">    QString Secret_Key = <span class="string">"K3tc1PQdcV2onyPUe4ICEtmgBdABWHCm"</span>;</span><br><span class="line">    manager = <span class="keyword">new</span> <span class="built_in">QNetworkAccessManager</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建请求对象</span></span><br><span class="line">    <span class="comment">//AppID: 23669392    API Key: Xokw5o3jf9lwUsqQX7mPzhf9  Secret Key: K3tc1PQdcV2onyPUe4ICEtmgBdABWHCm</span></span><br><span class="line">    <span class="comment">//https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=Xokw5o3jf9lwUsqQX7mPzhf9&amp;client_secret=K3tc1PQdcV2onyPUe4ICEtmgBdABWHCm&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求url</span></span><br><span class="line">    <span class="comment">//    QString requestUrl = "https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;";</span></span><br><span class="line">    <span class="comment">//    requestUrl += QString("client_id=%1&amp;").arg(API_Key);</span></span><br><span class="line">    <span class="comment">//    requestUrl += QString("client_secret=%1").arg(Secret_Key);</span></span><br><span class="line"></span><br><span class="line">    QString requestUrl = <span class="string">"https://aip.baidubce.com/oauth/2.0/token?"</span>;</span><br><span class="line">    QString data =<span class="built_in">QString</span>(<span class="string">"grant_type=client_credentials&amp;client_id=Xokw5o3jf9lwUsqQX7mPzhf9&amp;client_secret=K3tc1PQdcV2onyPUe4ICEtmgBdABWHCm&amp;"</span>);</span><br><span class="line">    QNetworkRequest request; <span class="comment">//http的类</span></span><br><span class="line">    request.<span class="built_in">setUrl</span>(<span class="built_in">QUrl</span>(requestUrl));</span><br><span class="line">    request.<span class="built_in">setRawHeader</span>(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>); <span class="comment">//设置http的头</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(manager,<span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>(QNetworkReply*)),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">networkReply</span>(QNetworkReply*)));</span><br><span class="line"></span><br><span class="line">    manager-&gt;<span class="built_in">post</span>(request,data.<span class="built_in">toLatin1</span>());<span class="comment">//提交http 的 post请求</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::networkReply</span><span class="params">(QNetworkReply* reply)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(reply-&gt;<span class="built_in">error</span>() == QNetworkReply::NoError)<span class="comment">//如果返回结果没有错误</span></span><br><span class="line">    {</span><br><span class="line">        QByteArray data = reply-&gt;<span class="built_in">readAll</span>();<span class="comment">//读取百度的返回结果</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; data;</span><br><span class="line">        QJsonDocument json =  QJsonDocument::<span class="built_in">fromJson</span>(data);<span class="comment">//QByteArrary -&gt; json</span></span><br><span class="line">        QJsonObject object = json.<span class="built_in">object</span>();<span class="comment">//转json对象</span></span><br><span class="line">        <span class="keyword">if</span>(object.<span class="built_in">isEmpty</span>() || !object.<span class="built_in">contains</span>(<span class="string">"access_token"</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        QString token =  object[<span class="string">"access_token"</span>].<span class="built_in">toString</span>();<span class="comment">//提取access_token</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"token: "</span>&lt;&lt; token;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; reply-&gt;<span class="built_in">errorString</span>();<span class="comment">//打印错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    reply-&gt;<span class="built_in">deleteLater</span>();<span class="comment">//delete reply</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>在 Qt 中，可以使用 QSqlDatabase 类来操作各种类型的数据库，包括 SQLite3 数据库。使用 SQLite3 数据库时，需要下载相应的驱动程序。通常情况下，驱动程序可以在 Qt 官网的下载页面上找到。</p>
<p>下面是使用 QSqlDatabase 操作 SQLite3 数据库的基本流程：</p>
<ol>
<li>引入头文件：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>打开数据库：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">"QSQLITE"</span>);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">"mydatabase.db"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.<span class="built_in">open</span>()) {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Database Error:"</span> &lt;&lt; db.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里创建了一个名为 <code>mydatabase.db</code> 的数据库文件，并打开了它。如果打开失败，会输出错误信息。</p>
<ol start="3">
<li>创建表：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line"><span class="keyword">if</span> (!query.<span class="built_in">exec</span>(<span class="string">"CREATE TABLE student (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)"</span>)) {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Query Error:"</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里创建了一个名为 <code>student</code> 的表，包含三个字段：<code>id</code>、<code>name</code> 和 <code>age</code>。</p>
<ol start="4">
<li>插入数据：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!query.<span class="built_in">exec</span>(<span class="string">"INSERT INTO student (name, age) VALUES ('Tom', 18)"</span>)) {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Query Error:"</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里向 <code>student</code> 表中插入了一条记录，其中 <code>name</code> 字段的值为 <code>Tom</code>，<code>age</code> 字段的值为 <code>18</code>。</p>
<ol start="5">
<li>查询数据：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!query.<span class="built_in">exec</span>(<span class="string">"SELECT * FROM student"</span>)) {</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"Query Error:"</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (query.<span class="built_in">next</span>()) {</span><br><span class="line">    <span class="type">int</span> id = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">    QString name = query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">    <span class="type">int</span> age = query.<span class="built_in">value</span>(<span class="number">2</span>).<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="string">"name:"</span> &lt;&lt; name &lt;&lt; <span class="string">"age:"</span> &lt;&lt; age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里查询了 <code>student</code> 表中的所有数据，并遍历了查询结果，输出了每条记录中 <code>id</code>、<code>name</code> 和 <code>age</code> 三个字段的值。</p>
<ol start="6">
<li>关闭数据库：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">db.<span class="built_in">close</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>这里关闭了数据库。</p>
<h2 id="风格样式表"><a href="#风格样式表" class="headerlink" title="风格样式表"></a>风格样式表</h2><p>Qt 提供了样式表（Style Sheet）的功能，可以使用 CSS 的语法来设置控件的外观和布局，实现界面的美化和自定义。</p>
<p>以下是使用样式表美化 Qt 界面的一些知识点：</p>
<ol>
<li>选择器：类似于 CSS 中的选择器，用于选择某个或某些控件，并设置样式。例如：</li>
</ol>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">QLabel {</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的样式表会将所有 QLabel 的字体颜色设置为蓝色，字体大小设置为 16 像素。</p>
<ol start="2">
<li>属性：样式表可以设置控件的各种属性，包括大小、颜色、边框、背景等。例如：</li>
</ol>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">QPushButton {</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的样式表会将所有 QPushButton 的边框设置为灰色实线，边框圆角设置为 5 像素，背景颜色设置为白色，内边距设置为 5 像素。</p>
<ol start="3">
<li>伪状态：样式表可以设置控件的伪状态，例如鼠标悬浮、按下、选中等状态下的样式。例如：</li>
</ol>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">}</span><br><span class="line">QPushButton:pressed {</span><br><span class="line">    <span class="attribute">background-color</span>: darkgray;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的样式表会将所有 QPushButton 在鼠标悬浮状态下的背景颜色设置为灰色，在鼠标按下状态下的背景颜色设置为深灰色。</p>
<ol start="4">
<li>布局：样式表可以设置控件的布局，例如控件之间的间距、对齐方式等。例如：</li>
</ol>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">QVBoxLayout {</span><br><span class="line">    spacing: <span class="number">10px</span>;</span><br><span class="line">    alignment: center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的样式表会将 QVBoxLayout 中的控件间距设置为 10 像素，对齐方式设置为居中对齐。</p>
<ol start="5">
<li>使用外部样式表：样式表可以使用外部样式表文件，通过加载文件来设置控件样式。例如：</li>
</ol>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">QFile qssFile(":/styles/style.qss<span class="string">");</span></span><br><span class="line"><span class="string">if (qssFile.open(QFile::ReadOnly)) {</span></span><br><span class="line"><span class="string">    QString styleSheet = QLatin1String(qssFile.readAll());</span></span><br><span class="line"><span class="string">    qApp-&gt;setStyleSheet(styleSheet);</span></span><br><span class="line"><span class="string">    qssFile.close();</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码会加载当前目录下名为 style.qss 的样式表文件，并应用于整个应用程序。</p>
<p>总之，样式表是 Qt 界面美化的重要工具，掌握了样式表的基本语法和属性，可以灵活地定制和美化应用程序的界面。</p>
<h3 id="单独设置"><a href="#单独设置" class="headerlink" title="单独设置"></a>单独设置</h3><h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><p>如果需要设置某一个控件的样式，可以使用控件的<code>setStyleSheet()</code>方法来设置。该方法接受一个QString类型的参数，参数内容为样式表的字符串。例如，如果要设置一个按钮的背景颜色为蓝色，可以这样写：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">btn.setStyleSheet(<span class="string">"background-color: blue"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果需要为多个控件设置相同的样式，可以使用样式表中的类选择器。例如，如果需要为所有按钮设置相同的背景颜色，可以这样写：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">QPushButton {</span><br><span class="line">    background-color: blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>除了设置背景颜色，样式表还可以设置字体、边框、圆角等多种样式。参考Qt的官方文档，可以找到所有支持的样式属性和样式选择器，从而进行更丰富的控件样式设置。</p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>是的，可以使用<code>objectName</code>属性来给控件命名，然后在样式表中使用该名字来选择对应的控件并设置其样式。例如，给一个QPushButton设置名字为”myButton”：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">QPushButton* button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">"Click me"</span>);</span><br><span class="line">button-&gt;<span class="built_in">setObjectName</span>(<span class="string">"myButton"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>然后可以在样式表中通过名字来设置该按钮的样式：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-id">#myButton</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，<code>#myButton</code>表示选择名字为”myButton”的控件，然后设置其背景颜色、文本颜色和字体大小。</p>
<h2 id="api调用"><a href="#api调用" class="headerlink" title="api调用"></a>api调用</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ui_widget.h"</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent), <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget) {</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QString API_Key = <span class="string">"zt7hUuu60LZB1kP3Vqr7mzeF"</span>;</span><br><span class="line">    QString Secret_Key = <span class="string">"wsrBT4uD1TsNI00demCN0gfEt7iMmFfR"</span>;</span><br><span class="line">    manager = <span class="keyword">new</span> <span class="built_in">QNetworkAccessManager</span>(<span class="keyword">this</span>);</span><br><span class="line">    QString requestUrl = <span class="string">"https://aip.baidubce.com/oauth/2.0/token"</span>;</span><br><span class="line">    QString data = <span class="built_in">QString</span>(<span class="string">"grant_type=%0"</span></span><br><span class="line">                           <span class="string">"&amp;client_id=%1&amp;"</span></span><br><span class="line">                           <span class="string">"client_secret=%2"</span>)</span><br><span class="line">                       .<span class="built_in">arg</span>(<span class="string">"client_credentials"</span>)</span><br><span class="line">                       .<span class="built_in">arg</span>(API_Key)</span><br><span class="line">                       .<span class="built_in">arg</span>(Secret_Key);</span><br><span class="line">    QNetworkRequest request; <span class="comment">//http的类</span></span><br><span class="line">    request.<span class="built_in">setUrl</span>(<span class="built_in">QUrl</span>(requestUrl));</span><br><span class="line">    request.<span class="built_in">setRawHeader</span>(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>); <span class="comment">//设置http的头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    jsonObj["grant_type"] = "client_credentials";</span></span><br><span class="line">    <span class="comment">//    jsonObj["client_id"] = API_Key;</span></span><br><span class="line">    <span class="comment">//    jsonObj["client_credentials"] = Secret_Key;</span></span><br><span class="line">    <span class="comment">//    QByteArray data = QJsonDocument(jsonObj).toJson(QJsonDocument::Compact);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(manager, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>(QNetworkReply *)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">networkReply</span>(QNetworkReply *)));</span><br><span class="line">    manager-&gt;<span class="built_in">post</span>(request, data.<span class="built_in">toLatin1</span>());</span><br><span class="line"></span><br><span class="line">    format.<span class="built_in">setSampleRate</span>(<span class="number">16000</span>);</span><br><span class="line">    format.<span class="built_in">setChannelCount</span>(<span class="number">1</span>);</span><br><span class="line">    format.<span class="built_in">setSampleFormat</span>(QAudioFormat::Int16);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() {</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">send</span>(ui-&gt;textEdit-&gt;<span class="built_in">toPlainText</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::networkReply</span><span class="params">(QNetworkReply *reply)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (reply-&gt;<span class="built_in">error</span>() == QNetworkReply::NoError) { <span class="comment">//如果返回结果没有错误</span></span><br><span class="line">        QByteArray data = reply-&gt;<span class="built_in">readAll</span>();         <span class="comment">//读取百度的返回结果</span></span><br><span class="line">        <span class="comment">//qDebug() &lt;&lt; data;</span></span><br><span class="line">        QJsonDocument json = QJsonDocument::<span class="built_in">fromJson</span>(data);       <span class="comment">//QByteArrary -&gt; json</span></span><br><span class="line">        QJsonObject object = json.<span class="built_in">object</span>();                       <span class="comment">//转json对象</span></span><br><span class="line">        <span class="keyword">if</span> (!object.<span class="built_in">isEmpty</span>() &amp;&amp; data.<span class="built_in">contains</span>(<span class="string">"access_token"</span>)) { <span class="comment">//包含access_token 请求令牌</span></span><br><span class="line">            token = object[<span class="string">"access_token"</span>].<span class="built_in">toString</span>();            <span class="comment">//提取access_token</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!object.<span class="built_in">isEmpty</span>() &amp;&amp; data.<span class="built_in">contains</span>(<span class="string">"action_id"</span>)) { <span class="comment">//返回问题回答</span></span><br><span class="line">            QJsonObject result = object[<span class="string">"result"</span>].<span class="built_in">toObject</span>();</span><br><span class="line">            QJsonObject response = result[<span class="string">"response"</span>].<span class="built_in">toObject</span>();</span><br><span class="line">            QJsonArray action_list = response[<span class="string">"action_list"</span>].<span class="built_in">toArray</span>();</span><br><span class="line">            QString say = action_list[<span class="number">0</span>].<span class="built_in">toObject</span>().<span class="built_in">value</span>(<span class="string">"say"</span>).<span class="built_in">toString</span>();</span><br><span class="line">            ui-&gt;textEdit_2-&gt;<span class="built_in">setText</span>(say);</span><br><span class="line">            <span class="built_in">toAudio</span>(say);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!object.<span class="built_in">isEmpty</span>() &amp;&amp; data.<span class="built_in">contains</span>(<span class="string">"corpus_no"</span>)) { <span class="comment">//语音识别结果</span></span><br><span class="line">            QJsonArray result = object[<span class="string">"result"</span>].<span class="built_in">toArray</span>();</span><br><span class="line">            ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(result[<span class="number">0</span>].<span class="built_in">toString</span>());</span><br><span class="line">            <span class="built_in">send</span>(result[<span class="number">0</span>].<span class="built_in">toString</span>());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">playAudio</span>(data);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; reply-&gt;<span class="built_in">errorString</span>(); <span class="comment">//打印错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    reply-&gt;<span class="built_in">deleteLater</span>(); <span class="comment">//delete reply</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_2_pressed</span><span class="params">()</span> </span>{ <span class="comment">//录音</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"录音"</span>;</span><br><span class="line"></span><br><span class="line">    sourceFile = <span class="keyword">new</span> <span class="built_in">QFile</span>(<span class="string">"audio.wav"</span>);</span><br><span class="line">    sourceFile-&gt;<span class="built_in">open</span>(QIODevice::ReadWrite);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//音频格式</span></span><br><span class="line"></span><br><span class="line">    <span class="function">QAudioDevice <span class="title">inputDevice</span><span class="params">(QMediaDevices::defaultAudioInput())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inputDevice.<span class="built_in">isFormatSupported</span>(format)) {</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">"Default input format not supported, trying to use the nearest."</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    audioSource = <span class="keyword">new</span> <span class="built_in">QAudioSource</span>(inputDevice, format, <span class="keyword">this</span>);</span><br><span class="line">    audioSource-&gt;<span class="built_in">start</span>(sourceFile);</span><br><span class="line">    timeout = <span class="number">20</span>;</span><br><span class="line">    timerid = <span class="built_in">startTimer</span>(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_2_released</span><span class="params">()</span> </span>{ <span class="comment">//结束录音</span></span><br><span class="line"></span><br><span class="line">    ui-&gt;pushButton_2-&gt;<span class="built_in">setText</span>(<span class="string">"录音"</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"结束录音"</span>;</span><br><span class="line">    audioSource-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    sourceFile-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> audioSource;</span><br><span class="line"></span><br><span class="line">    sourceFile-&gt;<span class="built_in">setFileName</span>(<span class="string">"audio.wav"</span>);</span><br><span class="line">    sourceFile-&gt;<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">    <span class="comment">//    QAudioDevice outputDevice(QMediaDevices::defaultAudioOutput());</span></span><br><span class="line">    <span class="comment">//    if (!outputDevice.isFormatSupported(format)) {</span></span><br><span class="line">    <span class="comment">//        qWarning() &lt;&lt; "Default output format not supported, trying to use the nearest.";</span></span><br><span class="line">    <span class="comment">//        return;</span></span><br><span class="line">    <span class="comment">//    }</span></span><br><span class="line">    <span class="comment">//    audioSink = new QAudioSink(outputDevice, format, this);</span></span><br><span class="line">    <span class="comment">//    audioSink-&gt;start(sourceFile);</span></span><br><span class="line">    <span class="comment">//sourceFile-&gt;close();</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) {</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">"提示"</span>, <span class="string">"语音过长"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">killTimer</span>(timerid);</span><br><span class="line">    }</span><br><span class="line">    QMessageBox::StandardButton button = QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, <span class="string">"确认"</span>, <span class="string">"确认发送?"</span>);</span><br><span class="line">    <span class="keyword">if</span> (button == QMessageBox::Yes) {</span><br><span class="line">        QString base64Data = sourceFile-&gt;<span class="built_in">readAll</span>().<span class="built_in">toBase64</span>();</span><br><span class="line">        QJsonObject jsonObject;</span><br><span class="line">        jsonObject[<span class="string">"format"</span>] = <span class="string">"wav"</span>;</span><br><span class="line">        jsonObject[<span class="string">"rate"</span>] = <span class="number">16000</span>;</span><br><span class="line">        jsonObject[<span class="string">"dev_pid"</span>] = <span class="number">1537</span>;</span><br><span class="line">        jsonObject[<span class="string">"channel"</span>] = <span class="number">1</span>;</span><br><span class="line">        jsonObject[<span class="string">"token"</span>] = token;</span><br><span class="line">        jsonObject[<span class="string">"cuid"</span>] = <span class="string">"123"</span>;</span><br><span class="line">        jsonObject[<span class="string">"len"</span>] = sourceFile-&gt;<span class="built_in">size</span>();</span><br><span class="line">        jsonObject[<span class="string">"speech"</span>] = base64Data;</span><br><span class="line"></span><br><span class="line">        <span class="function">QJsonDocument <span class="title">jsonDoc</span><span class="params">(jsonObject)</span></span>;</span><br><span class="line">        QByteArray jsonData = jsonDoc.<span class="built_in">toJson</span>(QJsonDocument::Compact);</span><br><span class="line"></span><br><span class="line">        QNetworkRequest request;</span><br><span class="line">        QString requestUrl = <span class="string">"http://vop.baidu.com/server_api"</span>;</span><br><span class="line">        request.<span class="built_in">setRawHeader</span>(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line">        request.<span class="built_in">setUrl</span>(<span class="built_in">QUrl</span>(requestUrl));</span><br><span class="line">        manager-&gt;<span class="built_in">post</span>(request, jsonData);</span><br><span class="line">        sourceFile-&gt;<span class="built_in">close</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::send</span><span class="params">(QString msg)</span> </span>{</span><br><span class="line">    QString requestUrl = <span class="string">"https://aip.baidubce.com/rpc/2.0/unit/bot/chat?access_token="</span> + token;</span><br><span class="line">    QJsonObject jsonObj;</span><br><span class="line">    QString skill = ui-&gt;comboBox-&gt;<span class="built_in">currentText</span>();</span><br><span class="line">    QString skill_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (skill == <span class="string">"智能问答"</span>) {</span><br><span class="line">        skill_id = <span class="string">"1349733"</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (skill == <span class="string">"音乐"</span>) {</span><br><span class="line">        skill_id = <span class="string">"1349736"</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (skill == <span class="string">"笑话"</span>) {</span><br><span class="line">        skill_id = <span class="string">"1349737"</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (skill == <span class="string">"闲聊"</span>) {</span><br><span class="line">        skill_id = <span class="string">"1349734"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    jsonObj[<span class="string">"version"</span>] = <span class="string">"2.0"</span>;</span><br><span class="line">    jsonObj[<span class="string">"service_id"</span>] = <span class="string">"S90591"</span>;</span><br><span class="line">    jsonObj[<span class="string">"session_id"</span>] = <span class="string">""</span>;</span><br><span class="line">    jsonObj[<span class="string">"skill_id"</span>] = skill_id;</span><br><span class="line">    jsonObj[<span class="string">"log_id"</span>] = <span class="string">"7758521"</span>;</span><br><span class="line">    QJsonObject problem;</span><br><span class="line">    problem[<span class="string">"user_id"</span>] = <span class="string">"123"</span>;</span><br><span class="line">    problem[<span class="string">"terminal_id"</span>] = <span class="string">"88888"</span>;</span><br><span class="line">    problem[<span class="string">"query"</span>] = msg;</span><br><span class="line">    jsonObj[<span class="string">"request"</span>] = problem;</span><br><span class="line">    QByteArray data = <span class="built_in">QJsonDocument</span>(jsonObj).<span class="built_in">toJson</span>(QJsonDocument::Compact);</span><br><span class="line"></span><br><span class="line">    QNetworkRequest request; <span class="comment">//http的类</span></span><br><span class="line">    request.<span class="built_in">setUrl</span>(<span class="built_in">QUrl</span>(requestUrl));</span><br><span class="line">    request.<span class="built_in">setRawHeader</span>(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>); <span class="comment">//设置http的头</span></span><br><span class="line">    manager-&gt;<span class="built_in">post</span>(request, data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::toAudio</span><span class="params">(QString msg)</span> </span>{</span><br><span class="line">    QString requestUrl = <span class="string">"http://tsn.baidu.com/text2audio"</span>;</span><br><span class="line"></span><br><span class="line">    QJsonObject jsonObject;</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"tex"</span>, msg);</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"tok"</span>, token);</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"cuid"</span>, <span class="string">"123"</span>);</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"ctp"</span>, <span class="string">"1"</span>);</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"lan"</span>, <span class="string">"zh"</span>);</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"spd"</span>, <span class="number">5</span>);</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"pit"</span>, <span class="number">5</span>);</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"vol"</span>, <span class="number">5</span>);</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"per"</span>, <span class="number">0</span>);</span><br><span class="line">    jsonObject.<span class="built_in">insert</span>(<span class="string">"aue"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    QUrlQuery query;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;key : jsonObject.<span class="built_in">keys</span>()) {</span><br><span class="line">        query.<span class="built_in">addQueryItem</span>(key, jsonObject.<span class="built_in">value</span>(key).<span class="built_in">toString</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    QString encodedString = query.<span class="built_in">toString</span>(QUrl::FullyEncoded);</span><br><span class="line"></span><br><span class="line">    QNetworkRequest request; <span class="comment">//http的类</span></span><br><span class="line">    request.<span class="built_in">setUrl</span>(<span class="built_in">QUrl</span>(requestUrl));</span><br><span class="line">    request.<span class="built_in">setRawHeader</span>(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>); <span class="comment">//设置http的头</span></span><br><span class="line">    manager-&gt;<span class="built_in">post</span>(request, encodedString.<span class="built_in">toLatin1</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::playAudio</span><span class="params">(QByteArray data)</span> </span>{</span><br><span class="line">    toAudioFile = <span class="keyword">new</span> <span class="built_in">QFile</span>(<span class="string">"toaduio.mp3"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!toAudioFile-&gt;<span class="built_in">open</span>(QIODevice::WriteOnly)) {</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">"Could not open file for writing"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">QDataStream <span class="title">out</span><span class="params">(toAudioFile)</span></span>;</span><br><span class="line">    out.<span class="built_in">writeRawData</span>(data.<span class="built_in">constData</span>(), data.<span class="built_in">size</span>());</span><br><span class="line">    toAudioFile-&gt;<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    toAudioFile-&gt;<span class="built_in">setFileName</span>(<span class="string">"toaduio.mp3"</span>);</span><br><span class="line">    toAudioFile-&gt;<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    QAudioDevice outputDevice(QMediaDevices::defaultAudioOutput());</span></span><br><span class="line">    <span class="comment">//    if (!outputDevice.isFormatSupported(format)) {</span></span><br><span class="line">    <span class="comment">//        qWarning() &lt;&lt; "Default output format not supported, trying to use the nearest.";</span></span><br><span class="line">    <span class="comment">//        return;</span></span><br><span class="line">    <span class="comment">//    }</span></span><br><span class="line">    <span class="comment">//    audioSink = new QAudioSink(outputDevice, format, this);</span></span><br><span class="line">    <span class="comment">//    audioSink-&gt;start(toAudioFile);</span></span><br><span class="line">    <span class="comment">//toAudioFile-&gt;close();</span></span><br><span class="line"></span><br><span class="line">    player = <span class="keyword">new</span> <span class="built_in">QMediaPlayer</span>();</span><br><span class="line">    QAudioOutput *audioOutput = <span class="keyword">new</span> <span class="built_in">QAudioOutput</span>();</span><br><span class="line">    player-&gt;<span class="built_in">setAudioOutput</span>(audioOutput);</span><br><span class="line">    player-&gt;<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">"toaduio.mp3"</span>));</span><br><span class="line">    audioOutput-&gt;<span class="built_in">setVolume</span>(<span class="number">50</span>);</span><br><span class="line">    player-&gt;<span class="built_in">play</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::timerEvent</span><span class="params">(QTimerEvent *event)</span> </span>{</span><br><span class="line">    ui-&gt;pushButton_2-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">"录音\t(%1s)"</span>).<span class="built_in">arg</span>(timeout--));</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">killTimer</span>(timerid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_3_clicked</span><span class="params">()</span> </span>{ <span class="comment">//暂停播放</span></span><br><span class="line">    <span class="keyword">if</span> (player-&gt;<span class="built_in">isPlaying</span>()) {</span><br><span class="line">        player-&gt;<span class="built_in">pause</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://miaobuyi.github.io">miaobuyi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://miaobuyi.github.io/2023/05/04/QT/">https://miaobuyi.github.io/2023/05/04/QT/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://miaobuyi.github.io" target="_blank">miaobuyi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://api.yimian.xyz/img" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/05/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img class="cover" src="https://api.yimian.xyz/img" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/19/C++/" title="C++"><img class="cover" src="https://imgapi.xl0408.top/index.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-1307795383.cos.ap-chengdu.myqcloud.com/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">miaobuyi</div><div class="author-info__description">人类的悲欢并不相通</br>我只觉得他们吵闹</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/miaobuyi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/miaobuyi" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2426012846@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%B7%A5%E5%85%B7"><span class="toc-text">三个工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-text">创建工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qt%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">qt内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#star-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">⭐信号与槽机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-text">信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-text">槽函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-text">关联信号与槽函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-text">自定义信号和槽函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="toc-text">常用组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D%E7%BB%98%E5%9B%BE"><span class="toc-text">2D绘图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QProcess"><span class="toc-text">QProcess</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-text">发送数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thread"><span class="toc-text">thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#moveToThread"><span class="toc-text">moveToThread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOCKET"><span class="toc-text">SOCKET</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDPSOCKET"><span class="toc-text">UDPSOCKET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCPSOCKET"><span class="toc-text">TCPSOCKET</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%8E%E6%A0%BC%E6%A0%B7%E5%BC%8F%E8%A1%A8"><span class="toc-text">风格样式表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%8B%AC%E8%AE%BE%E7%BD%AE"><span class="toc-text">单独设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E6%96%B9%E6%B3%95"><span class="toc-text">set方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-text">选择器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api%E8%B0%83%E7%94%A8"><span class="toc-text">api调用</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/15/ARM%E6%9E%B6%E6%9E%84/" title="ARM架构"><img src="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM架构"/></a><div class="content"><a class="title" href="/2023/05/15/ARM%E6%9E%B6%E6%9E%84/" title="ARM架构">ARM架构</a><time datetime="2023-05-15T01:05:32.000Z" title="发表于 2023-05-15 09:05:32">2023-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/05/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img src="https://api.yimian.xyz/img" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题"/></a><div class="content"><a class="title" href="/2023/05/05/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a><time datetime="2023-05-05T14:21:30.000Z" title="发表于 2023-05-05 22:21:30">2023-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/04/QT/" title="QT"><img src="https://api.yimian.xyz/img" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QT"/></a><div class="content"><a class="title" href="/2023/05/04/QT/" title="QT">QT</a><time datetime="2023-05-04T09:12:32.000Z" title="发表于 2023-05-04 17:12:32">2023-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/19/C++/" title="C++"><img src="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++"/></a><div class="content"><a class="title" href="/2023/04/19/C++/" title="C++">C++</a><time datetime="2023-04-19T11:20:40.000Z" title="发表于 2023-04-19 19:20:40">2023-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/vim%E6%A8%A1%E6%9D%BF/" title="vim模板"><img src="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vim模板"/></a><div class="content"><a class="title" href="/2023/04/17/vim%E6%A8%A1%E6%9D%BF/" title="vim模板">vim模板</a><time datetime="2023-04-17T02:41:45.000Z" title="发表于 2023-04-17 10:41:45">2023-04-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://api.yimian.xyz/img')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By miaobuyi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><div class="aplayer no-destroy" data-id="5463524537" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><script defer src="https://rmt.dogedoge.com/fetch/~/source/jsdelivr/npm/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/gh/sirxemic/jquery.ripples/dist/jquery.ripples.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>